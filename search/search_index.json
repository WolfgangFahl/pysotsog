{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pysotsog API Documentation","text":""},{"location":"#skg.citeproc","title":"<code>citeproc</code>","text":"<p>Created on 2022-12-21</p> <p>@author: wf</p>"},{"location":"#skg.citeproc.Citeproc","title":"<code>Citeproc</code>","text":"<p>see https://en.wikipedia.org/wiki/CiteProc</p> Source code in <code>skg/citeproc.py</code> <pre><code>class Citeproc:\n    \"\"\"\n    see https://en.wikipedia.org/wiki/CiteProc\n    \"\"\"\n\n    @classmethod\n    def asScite(cls, meta_data: dict, retrieved_from: str) -&gt; str:\n        \"\"\"\n        convert the given meta data to #Scite format\n\n        see https://github.com/SemanticMediaWiki/SemanticCite/blob/master/src/FilteredMetadata/BibliographicFilteredRecord.php\n        Args:\n            meta_data(dict): the citeproc compatible metadata dict to convert\n            retrieved_from(str): the url the metadata was retrieved from\n\n        Returns:\n            str: Semantic Mediawiki markup\n        \"\"\"\n\n        def unlist(value):\n            if type(value) != list:\n                return value\n            text = \"\"\n            delim = \"\"\n            for item in value:\n                text += f\"{delim}{item}\"\n                delim = \";\"\n            if len(value) &gt; 1:\n                text += \"|+sep=;\"\n            return text\n\n        def firstValue(value):\n            if type(value) != list:\n                return value\n            else:\n                return value[0]\n\n        def get_author(value) -&gt; str:\n            \"\"\"\n            get the author markup\n\n            Args:\n                value(list): the list to disassemble\n\n            Returns:\n                str: Mediawiki markup\n            \"\"\"\n            author = \"\"\n            delim = \"\"\n            for arec in value:\n                if \"given\" in arec and \"family\" in arec:\n                    author += f\"\"\"{delim}{arec[\"given\"]} {arec[\"family\"]}\"\"\"\n                    delim = \";\"\n                elif \"family\" in arec:\n                    author += f\"\"\"{delim}{arec[\"family\"]}\"\"\"\n                    delim = \";\"\n                else:\n                    # incomplete author record ignored\n                    pass\n            return author\n\n        timestamp = datetime.datetime.utcnow().strftime(\"%Y-%m-%d\")\n        ref_type = \"journal-article\"\n        title = meta_data[\"title\"]\n        if type(title) is list:\n            title = title[0]\n        title_2 = title.lower()[:2]\n        author_lower = \"\"\n        if \"author\" in meta_data:\n            first_author = firstValue(meta_data[\"author\"])\n            if \"family\" in first_author:\n                family = firstValue(first_author[\"family\"])\n                author_lower = family.lower()\n            else:\n                # debug break point\n                pass\n        year = \"\"\n        if \"published-print\" in meta_data:\n            year = meta_data[\"published-print\"][\"date-parts\"][0][0]\n        if not year and \"issued\" in meta_data:\n            year = meta_data[\"issued\"][\"date-parts\"][0][0]\n        reference = f\"{author_lower}{year}{title_2}\"\n        markup = \"\"\n        for skey, mkey, func in [\n            (\"title\", \"title\", unlist),\n            (\"subtitle\", \"subtitle\", unlist),\n            (\"authors\", \"author\", get_author),\n            (\"journal\", \"container-title\", unlist),\n            (\"publisher\", \"publisher\", str),\n            (\"issn\", \"ISSN\", unlist),\n            (\"subject\", \"subject\", unlist),\n            (\"volume\", \"volume\", str),\n            (\"pages\", \"page\", str),\n            (\"doi\", \"DOI\", str),\n        ]:\n            if mkey in meta_data:\n                value = meta_data[mkey]\n                if value:\n                    value = func(value)\n                    markup += f\"\\n|{skey}={value}\"\n        markup = f\"\"\"{{{{#scite:\n|reference={reference}\n|type={ref_type}{markup}\n|year={year}\n|retrieved-from={retrieved_from}\n|retrieved-on={timestamp}\n}}}}\"\"\"\n        full_markup = f\"{title}\\n[[CiteRef::{reference}]]\\n{markup}\"\n        return full_markup\n</code></pre>"},{"location":"#skg.citeproc.Citeproc.asScite","title":"<code>asScite(meta_data, retrieved_from)</code>  <code>classmethod</code>","text":"<p>convert the given meta data to #Scite format</p> <p>see https://github.com/SemanticMediaWiki/SemanticCite/blob/master/src/FilteredMetadata/BibliographicFilteredRecord.php Args:     meta_data(dict): the citeproc compatible metadata dict to convert     retrieved_from(str): the url the metadata was retrieved from</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Semantic Mediawiki markup</p> Source code in <code>skg/citeproc.py</code> <pre><code>    @classmethod\n    def asScite(cls, meta_data: dict, retrieved_from: str) -&gt; str:\n        \"\"\"\n        convert the given meta data to #Scite format\n\n        see https://github.com/SemanticMediaWiki/SemanticCite/blob/master/src/FilteredMetadata/BibliographicFilteredRecord.php\n        Args:\n            meta_data(dict): the citeproc compatible metadata dict to convert\n            retrieved_from(str): the url the metadata was retrieved from\n\n        Returns:\n            str: Semantic Mediawiki markup\n        \"\"\"\n\n        def unlist(value):\n            if type(value) != list:\n                return value\n            text = \"\"\n            delim = \"\"\n            for item in value:\n                text += f\"{delim}{item}\"\n                delim = \";\"\n            if len(value) &gt; 1:\n                text += \"|+sep=;\"\n            return text\n\n        def firstValue(value):\n            if type(value) != list:\n                return value\n            else:\n                return value[0]\n\n        def get_author(value) -&gt; str:\n            \"\"\"\n            get the author markup\n\n            Args:\n                value(list): the list to disassemble\n\n            Returns:\n                str: Mediawiki markup\n            \"\"\"\n            author = \"\"\n            delim = \"\"\n            for arec in value:\n                if \"given\" in arec and \"family\" in arec:\n                    author += f\"\"\"{delim}{arec[\"given\"]} {arec[\"family\"]}\"\"\"\n                    delim = \";\"\n                elif \"family\" in arec:\n                    author += f\"\"\"{delim}{arec[\"family\"]}\"\"\"\n                    delim = \";\"\n                else:\n                    # incomplete author record ignored\n                    pass\n            return author\n\n        timestamp = datetime.datetime.utcnow().strftime(\"%Y-%m-%d\")\n        ref_type = \"journal-article\"\n        title = meta_data[\"title\"]\n        if type(title) is list:\n            title = title[0]\n        title_2 = title.lower()[:2]\n        author_lower = \"\"\n        if \"author\" in meta_data:\n            first_author = firstValue(meta_data[\"author\"])\n            if \"family\" in first_author:\n                family = firstValue(first_author[\"family\"])\n                author_lower = family.lower()\n            else:\n                # debug break point\n                pass\n        year = \"\"\n        if \"published-print\" in meta_data:\n            year = meta_data[\"published-print\"][\"date-parts\"][0][0]\n        if not year and \"issued\" in meta_data:\n            year = meta_data[\"issued\"][\"date-parts\"][0][0]\n        reference = f\"{author_lower}{year}{title_2}\"\n        markup = \"\"\n        for skey, mkey, func in [\n            (\"title\", \"title\", unlist),\n            (\"subtitle\", \"subtitle\", unlist),\n            (\"authors\", \"author\", get_author),\n            (\"journal\", \"container-title\", unlist),\n            (\"publisher\", \"publisher\", str),\n            (\"issn\", \"ISSN\", unlist),\n            (\"subject\", \"subject\", unlist),\n            (\"volume\", \"volume\", str),\n            (\"pages\", \"page\", str),\n            (\"doi\", \"DOI\", str),\n        ]:\n            if mkey in meta_data:\n                value = meta_data[mkey]\n                if value:\n                    value = func(value)\n                    markup += f\"\\n|{skey}={value}\"\n        markup = f\"\"\"{{{{#scite:\n|reference={reference}\n|type={ref_type}{markup}\n|year={year}\n|retrieved-from={retrieved_from}\n|retrieved-on={timestamp}\n}}}}\"\"\"\n        full_markup = f\"{title}\\n[[CiteRef::{reference}]]\\n{markup}\"\n        return full_markup\n</code></pre>"},{"location":"#skg.crossref","title":"<code>crossref</code>","text":"<p>Created on 17.11.2022</p> <p>@author: wf</p>"},{"location":"#skg.crossref.Crossref","title":"<code>Crossref</code>","text":"<p>Crossref access</p> Source code in <code>skg/crossref.py</code> <pre><code>class Crossref:\n    \"\"\"\n    Crossref access\n    \"\"\"\n\n    def __init__(self, mailto=None, ua_string=None):\n        \"\"\"\n        constructor\n        \"\"\"\n        if mailto is None:\n            mailto = \"wf@bitplan.com\"\n        if ua_string is None:\n            ua_string = f\"pysotsog/{skg.__version__} (https://pypi.org/project/pysotsog/; mailto:{mailto})\"\n        # self.cr = habanero.Crossref(mailto=mailto,ua_string=ua_string)\n        self.cr = habanero.Crossref(ua_string=\"\")\n\n    def doiMetaData(self, dois: list):\n        \"\"\"\n        get the meta data for the given dois\n\n        Args:\n            doi(list): a list of dois\n        \"\"\"\n        metadata = None\n        response = self.cr.works(ids=dois)\n        if (\n            \"status\" in response\n            and \"message\" in response\n            and response[\"status\"] == \"ok\"\n        ):\n            metadata = response[\"message\"]\n        return metadata\n\n    def doiBibEntry(self, dois: list):\n        \"\"\"\n        get bib entries for the given dois\n        \"\"\"\n        bibentry = cn.content_negotiation(ids=dois, format=\"bibentry\")\n        return bibentry\n\n    def asScite(self, meta_data: dict) -&gt; str:\n        \"\"\"\n        convert the given meta data to #Scite format\n\n        see https://github.com/SemanticMediaWiki/SemanticCite/blob/master/src/FilteredMetadata/BibliographicFilteredRecord.php\n\n        Returns:\n            str: Semantic Mediawiki markup\n        \"\"\"\n        markup = Citeproc.asScite(meta_data, retrieved_from=self.cr.base_url)\n        return markup\n</code></pre>"},{"location":"#skg.crossref.Crossref.__init__","title":"<code>__init__(mailto=None, ua_string=None)</code>","text":"<p>constructor</p> Source code in <code>skg/crossref.py</code> <pre><code>def __init__(self, mailto=None, ua_string=None):\n    \"\"\"\n    constructor\n    \"\"\"\n    if mailto is None:\n        mailto = \"wf@bitplan.com\"\n    if ua_string is None:\n        ua_string = f\"pysotsog/{skg.__version__} (https://pypi.org/project/pysotsog/; mailto:{mailto})\"\n    # self.cr = habanero.Crossref(mailto=mailto,ua_string=ua_string)\n    self.cr = habanero.Crossref(ua_string=\"\")\n</code></pre>"},{"location":"#skg.crossref.Crossref.asScite","title":"<code>asScite(meta_data)</code>","text":"<p>convert the given meta data to #Scite format</p> <p>see https://github.com/SemanticMediaWiki/SemanticCite/blob/master/src/FilteredMetadata/BibliographicFilteredRecord.php</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Semantic Mediawiki markup</p> Source code in <code>skg/crossref.py</code> <pre><code>def asScite(self, meta_data: dict) -&gt; str:\n    \"\"\"\n    convert the given meta data to #Scite format\n\n    see https://github.com/SemanticMediaWiki/SemanticCite/blob/master/src/FilteredMetadata/BibliographicFilteredRecord.php\n\n    Returns:\n        str: Semantic Mediawiki markup\n    \"\"\"\n    markup = Citeproc.asScite(meta_data, retrieved_from=self.cr.base_url)\n    return markup\n</code></pre>"},{"location":"#skg.crossref.Crossref.doiBibEntry","title":"<code>doiBibEntry(dois)</code>","text":"<p>get bib entries for the given dois</p> Source code in <code>skg/crossref.py</code> <pre><code>def doiBibEntry(self, dois: list):\n    \"\"\"\n    get bib entries for the given dois\n    \"\"\"\n    bibentry = cn.content_negotiation(ids=dois, format=\"bibentry\")\n    return bibentry\n</code></pre>"},{"location":"#skg.crossref.Crossref.doiMetaData","title":"<code>doiMetaData(dois)</code>","text":"<p>get the meta data for the given dois</p> <p>Parameters:</p> Name Type Description Default <code>doi(list)</code> <p>a list of dois</p> required Source code in <code>skg/crossref.py</code> <pre><code>def doiMetaData(self, dois: list):\n    \"\"\"\n    get the meta data for the given dois\n\n    Args:\n        doi(list): a list of dois\n    \"\"\"\n    metadata = None\n    response = self.cr.works(ids=dois)\n    if (\n        \"status\" in response\n        and \"message\" in response\n        and response[\"status\"] == \"ok\"\n    ):\n        metadata = response[\"message\"]\n    return metadata\n</code></pre>"},{"location":"#skg.dblp","title":"<code>dblp</code>","text":"<p>Created on 2022-11-17</p> <p>@author: wf</p>"},{"location":"#skg.dblp.Dblp","title":"<code>Dblp</code>","text":"<p>Schloss Dagstuhl Dblp computer science bibliography</p> Source code in <code>skg/dblp.py</code> <pre><code>class Dblp:\n    \"\"\"\n    Schloss Dagstuhl Dblp computer science bibliography\n    \"\"\"\n\n    def __init__(self, endpoint: str = \"https://qlever.cs.uni-freiburg.de/api/dblp\"):\n        \"\"\"\n        constructor\n\n        Args:\n            endpoint(str): the endpoint to use\n        \"\"\"\n        self.endpoint = endpoint\n        self.schema = Owl(\n            \"dblp\", \"https://dblp.org/rdf/schema\", \"Wolfgang Fahl\", \"2022-11-19\"\n        )\n        self.sparql = SPARQL(self.endpoint)\n\n    def get_paper_records(\n        self,\n        regex: str,\n        prop_name: str = \"title\",\n        limit: int = 100,\n        debug: bool = False,\n    ) -&gt; list:\n        \"\"\"\n        get papers fitting the given regex\n\n        Args:\n            prop_name(str): the property to filter\n            regex(str): the regex to filter for\n            limit(int): the maximum number of records to return\n            debug(bool): if True show debug information\n\n        Returns:\n            list: a list of dict of paper records\n        \"\"\"\n        sparql_query = \"\"\"PREFIX dblp: &lt;https://dblp.org/rdf/schema#&gt;\nPREFIX xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;\nSELECT\n  ?paper \n  ?year\n  ?yearofevent\n  #?month\n  ?doi\n  ?isbn\n  ?title\n  (GROUP_CONCAT(?author_o) as ?authors)\n  ?publishedin\nWHERE {\n  ?paper dblp:title ?title .\n  ?paper dblp:doi ?doi .\n  OPTIONAL { ?paper dblp:yearOfEvent ?yearofevent } .\n  OPTIONAL { ?paper dblp:isbn ?isbn }.\n  ?paper dblp:authoredBy ?author_o.\n  ?paper dblp:publishedIn ?publishedin .\n  ?paper dblp:yearOfPublication ?year.\n  OPTIONAL { ?paper dblp:monthOfPublication ?month}.\n\"\"\"\n        sparql_query += f\"\"\"FILTER regex(?{prop_name}, \"{regex}\").\\n\"\"\"\n        sparql_query += f\"\"\"\n}}\nGROUP BY \n  ?paper \n  ?title \n  ?doi \n  ?isbn\n  ?year \n  ?yearofevent\n  ?month \n  ?publishedin \nORDER BY DESC(?year)\nLIMIT {limit}\"\"\"\n        if debug:\n            print(sparql_query)\n        records = self.sparql.queryAsListOfDicts(sparql_query)\n        return records\n\n    def get_random_papers(self, year: int = 2020, limit: int = 10):\n        sparql_query = f\"\"\"PREFIX dblp: &lt;https://dblp.org/rdf/schema#&gt;\nSELECT \n  ?paper \n  (SAMPLE(?doi_o) as ?doi)\n  (SAMPLE(?title_o) as ?title)\n  (MIN(?year_o) as ?year)\n  (GROUP_CONCAT(?author_o) as ?authors)\n  (SAMPLE(?publishedin_o) as ?publishedin)\n  (SAMPLE(?sortKey) as ?sortKey)\nWHERE {{\n  VALUES ?year_o {{ \"{year}\" }}\n  ?paper dblp:title ?title_o .\n  ?paper dblp:doi ?doi_o .\n  ?paper dblp:authoredBy ?author_o.\n  ?paper dblp:publishedIn ?publishedin_o .\n  ?paper dblp:yearOfPublication ?year_o.\n  BIND(RAND() AS ?sortKey)\n}}\nGROUP BY ?paper\nORDER BY ?sortKey \nLIMIT {limit}\n        \"\"\"\n</code></pre>"},{"location":"#skg.dblp.Dblp.__init__","title":"<code>__init__(endpoint='https://qlever.cs.uni-freiburg.de/api/dblp')</code>","text":"<p>constructor</p> <p>Parameters:</p> Name Type Description Default <code>endpoint(str)</code> <p>the endpoint to use</p> required Source code in <code>skg/dblp.py</code> <pre><code>def __init__(self, endpoint: str = \"https://qlever.cs.uni-freiburg.de/api/dblp\"):\n    \"\"\"\n    constructor\n\n    Args:\n        endpoint(str): the endpoint to use\n    \"\"\"\n    self.endpoint = endpoint\n    self.schema = Owl(\n        \"dblp\", \"https://dblp.org/rdf/schema\", \"Wolfgang Fahl\", \"2022-11-19\"\n    )\n    self.sparql = SPARQL(self.endpoint)\n</code></pre>"},{"location":"#skg.dblp.Dblp.get_paper_records","title":"<code>get_paper_records(regex, prop_name='title', limit=100, debug=False)</code>","text":"<p>get papers fitting the given regex</p> <p>Parameters:</p> Name Type Description Default <code>prop_name(str)</code> <p>the property to filter</p> required <code>regex(str)</code> <p>the regex to filter for</p> required <code>limit(int)</code> <p>the maximum number of records to return</p> required <code>debug(bool)</code> <p>if True show debug information</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>a list of dict of paper records</p> Source code in <code>skg/dblp.py</code> <pre><code>    def get_paper_records(\n        self,\n        regex: str,\n        prop_name: str = \"title\",\n        limit: int = 100,\n        debug: bool = False,\n    ) -&gt; list:\n        \"\"\"\n        get papers fitting the given regex\n\n        Args:\n            prop_name(str): the property to filter\n            regex(str): the regex to filter for\n            limit(int): the maximum number of records to return\n            debug(bool): if True show debug information\n\n        Returns:\n            list: a list of dict of paper records\n        \"\"\"\n        sparql_query = \"\"\"PREFIX dblp: &lt;https://dblp.org/rdf/schema#&gt;\nPREFIX xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;\nSELECT\n  ?paper \n  ?year\n  ?yearofevent\n  #?month\n  ?doi\n  ?isbn\n  ?title\n  (GROUP_CONCAT(?author_o) as ?authors)\n  ?publishedin\nWHERE {\n  ?paper dblp:title ?title .\n  ?paper dblp:doi ?doi .\n  OPTIONAL { ?paper dblp:yearOfEvent ?yearofevent } .\n  OPTIONAL { ?paper dblp:isbn ?isbn }.\n  ?paper dblp:authoredBy ?author_o.\n  ?paper dblp:publishedIn ?publishedin .\n  ?paper dblp:yearOfPublication ?year.\n  OPTIONAL { ?paper dblp:monthOfPublication ?month}.\n\"\"\"\n        sparql_query += f\"\"\"FILTER regex(?{prop_name}, \"{regex}\").\\n\"\"\"\n        sparql_query += f\"\"\"\n}}\nGROUP BY \n  ?paper \n  ?title \n  ?doi \n  ?isbn\n  ?year \n  ?yearofevent\n  ?month \n  ?publishedin \nORDER BY DESC(?year)\nLIMIT {limit}\"\"\"\n        if debug:\n            print(sparql_query)\n        records = self.sparql.queryAsListOfDicts(sparql_query)\n        return records\n</code></pre>"},{"location":"#skg.dblp2wikidata","title":"<code>dblp2wikidata</code>","text":"<p>Created on 2024-02-26</p> <p>@author: wf</p>"},{"location":"#skg.dblp2wikidata.Dblp2Wikidata","title":"<code>Dblp2Wikidata</code>","text":"<p>utility for transfering Dblp person entries to Wikidata</p> Source code in <code>skg/dblp2wikidata.py</code> <pre><code>class Dblp2Wikidata:\n    \"\"\"\n    utility for transfering Dblp person entries to Wikidata\n    \"\"\"\n\n    def __init__(self, debug: bool = False):\n        self.debug = debug\n        pass\n\n    def transfer(self, args: Namespace):\n        \"\"\"\n        Main method to handle the transfer of DBLP entries to Wikidata.\n\n        Args:\n            args(Namespace): Command line arguments.\n        \"\"\"\n        search_term = getattr(args, \"dblp2wikidata\", None)\n        if self.debug:\n            print(f\"trying to synchronize DBLP person entry for {search_term}\")\n</code></pre>"},{"location":"#skg.dblp2wikidata.Dblp2Wikidata.transfer","title":"<code>transfer(args)</code>","text":"<p>Main method to handle the transfer of DBLP entries to Wikidata.</p> <p>Parameters:</p> Name Type Description Default <code>args(Namespace)</code> <p>Command line arguments.</p> required Source code in <code>skg/dblp2wikidata.py</code> <pre><code>def transfer(self, args: Namespace):\n    \"\"\"\n    Main method to handle the transfer of DBLP entries to Wikidata.\n\n    Args:\n        args(Namespace): Command line arguments.\n    \"\"\"\n    search_term = getattr(args, \"dblp2wikidata\", None)\n    if self.debug:\n        print(f\"trying to synchronize DBLP person entry for {search_term}\")\n</code></pre>"},{"location":"#skg.doi","title":"<code>doi</code>","text":"<p>Created on 2022-11-22</p> <p>@author: wf</p>"},{"location":"#skg.doi.DOI","title":"<code>DOI</code>","text":"<p>Digital Object Identifier handling</p> <p>see e.g. https://www.wikidata.org/wiki/Property:P356 see https://www.doi.org/doi_handbook/2_Numbering.html#2.2 see https://github.com/davidagraf/doi2bib2/blob/master/server/doi2bib.js see https://citation.crosscite.org/docs.html</p> Source code in <code>skg/doi.py</code> <pre><code>class DOI:\n    \"\"\"\n    Digital Object Identifier handling\n\n    see e.g. https://www.wikidata.org/wiki/Property:P356\n    see https://www.doi.org/doi_handbook/2_Numbering.html#2.2\n    see https://github.com/davidagraf/doi2bib2/blob/master/server/doi2bib.js\n    see https://citation.crosscite.org/docs.html\n\n    \"\"\"\n\n    pattern = re.compile(\n        r\"((?P&lt;directory_indicator&gt;10)\\.(?P&lt;registrant_code&gt;[0-9]{4,})(?:\\.[0-9]+)*(?:\\/|%2F)(?:(?![\\\"&amp;\\'])\\S)+)\"\n    )\n\n    def __init__(self, doi: str):\n        \"\"\"\n        a DOI\n        \"\"\"\n        self.doi = doi\n        match = re.match(DOI.pattern, doi)\n        self.ok = bool(match)\n        if self.ok:\n            self.registrant_code = match.group(\"registrant_code\")\n\n    @classmethod\n    def isDOI(cls, doi: str):\n        \"\"\"\n        check that the given string is a doi\n\n        Args:\n            doi(str): the potential DOI string\n        \"\"\"\n        if not doi:\n            return False\n        if isinstance(doi, list):\n            ok = len(doi) &gt; 0\n            for single_doi in doi:\n                ok = ok and cls.isDOI(single_doi)\n            return ok\n        if not isinstance(doi, str):\n            return False\n        doi_obj = DOI(doi)\n        return doi_obj.ok\n\n    def fetch_response(self, url: str, headers: dict):\n        \"\"\"\n        fetch reponse for the given url with the given headers\n\n        Args:\n            url(str): the url to fetch the data for\n            headers(dict): the headers to use\n        \"\"\"\n        req = urllib.request.Request(url, headers=headers)\n        response = urllib.request.urlopen(req)\n        return response\n\n    def fetch_json(self, url: str, headers: dict):\n        \"\"\"\n        fetch json for the given url with the given headers\n\n        Args:\n            url(str): the url to fetch the data for\n            headers(dict): the headers to use\n\n        Returns:\n            json: json data\n        \"\"\"\n        # async with aiohttp.ClientSession(headers=headers) as session:\n        #    async with session.get(url) as response:\n        #        return await response.json()\n        text = self.fetch_text(url, headers)\n        json_data = json.loads(text)\n        return json_data\n\n    def fetch_text(self, url, headers) -&gt; str:\n        \"\"\"\n        fetch text for the given url with the given headers\n\n        Args:\n            url(str): the url to fetch the data for\n            headers(dict): the headers to use\n\n        Returns:\n            str: the text\n        \"\"\"\n        # async with aiohttp.ClientSession(headers=headers) as session:\n        #    async with session.get(url) as response:\n        #        return await response.text()\n        response = self.fetch_response(url, headers)\n        encoding = response.headers.get_content_charset(\"utf-8\")\n        content = response.read()\n        text = content.decode(encoding)\n        return text\n\n    def doi2bibTex(self):\n        \"\"\"\n        get the bibtex result for my doi\n        \"\"\"\n        url = f\"https://doi.org/{self.doi}\"\n        headers = {\"Accept\": \"application/x-bibtex; charset=utf-8\"}\n        return self.fetch_text(url, headers)\n\n    def doi2Citeproc(self):\n        \"\"\"\n        get the Citeproc JSON result for my doi\n        see https://citeproc-js.readthedocs.io/en/latest/csl-json/markup.html\n        \"\"\"\n        url = f\"https://doi.org/{self.doi}\"\n        headers = {\"Accept\": \"application/vnd.citationstyles.csl+json; charset=utf-8\"}\n        return self.fetch_json(url, headers)\n\n    def dataCiteLookup(self):\n        \"\"\"\n        get the dataCite json result for my doi\n        \"\"\"\n        url = f\"https://api.datacite.org/dois/{self.doi}\"\n        headers = {\"Accept\": \"application/vnd.api+json; charset=utf-8\"}\n        return self.fetch_json(url, headers)\n\n    def asScite(self) -&gt; str:\n        \"\"\"\n        get DOI metadata and convert to Semantic Cite markup\n\n           see https://github.com/SemanticMediaWiki/SemanticCite/blob/master/src/FilteredMetadata/BibliographicFilteredRecord.php\n\n        Returns:\n            str: Semantic Mediawiki markup\n        \"\"\"\n        if not hasattr(self, \"meta_data\"):\n            self.meta_data = self.doi2Citeproc()\n        markup = Citeproc.asScite(self.meta_data, retrieved_from=\"https://doi.org/\")\n        return markup\n</code></pre>"},{"location":"#skg.doi.DOI.__init__","title":"<code>__init__(doi)</code>","text":"<p>a DOI</p> Source code in <code>skg/doi.py</code> <pre><code>def __init__(self, doi: str):\n    \"\"\"\n    a DOI\n    \"\"\"\n    self.doi = doi\n    match = re.match(DOI.pattern, doi)\n    self.ok = bool(match)\n    if self.ok:\n        self.registrant_code = match.group(\"registrant_code\")\n</code></pre>"},{"location":"#skg.doi.DOI.asScite","title":"<code>asScite()</code>","text":"<p>get DOI metadata and convert to Semantic Cite markup</p> <p>see https://github.com/SemanticMediaWiki/SemanticCite/blob/master/src/FilteredMetadata/BibliographicFilteredRecord.php</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Semantic Mediawiki markup</p> Source code in <code>skg/doi.py</code> <pre><code>def asScite(self) -&gt; str:\n    \"\"\"\n    get DOI metadata and convert to Semantic Cite markup\n\n       see https://github.com/SemanticMediaWiki/SemanticCite/blob/master/src/FilteredMetadata/BibliographicFilteredRecord.php\n\n    Returns:\n        str: Semantic Mediawiki markup\n    \"\"\"\n    if not hasattr(self, \"meta_data\"):\n        self.meta_data = self.doi2Citeproc()\n    markup = Citeproc.asScite(self.meta_data, retrieved_from=\"https://doi.org/\")\n    return markup\n</code></pre>"},{"location":"#skg.doi.DOI.dataCiteLookup","title":"<code>dataCiteLookup()</code>","text":"<p>get the dataCite json result for my doi</p> Source code in <code>skg/doi.py</code> <pre><code>def dataCiteLookup(self):\n    \"\"\"\n    get the dataCite json result for my doi\n    \"\"\"\n    url = f\"https://api.datacite.org/dois/{self.doi}\"\n    headers = {\"Accept\": \"application/vnd.api+json; charset=utf-8\"}\n    return self.fetch_json(url, headers)\n</code></pre>"},{"location":"#skg.doi.DOI.doi2Citeproc","title":"<code>doi2Citeproc()</code>","text":"<p>get the Citeproc JSON result for my doi see https://citeproc-js.readthedocs.io/en/latest/csl-json/markup.html</p> Source code in <code>skg/doi.py</code> <pre><code>def doi2Citeproc(self):\n    \"\"\"\n    get the Citeproc JSON result for my doi\n    see https://citeproc-js.readthedocs.io/en/latest/csl-json/markup.html\n    \"\"\"\n    url = f\"https://doi.org/{self.doi}\"\n    headers = {\"Accept\": \"application/vnd.citationstyles.csl+json; charset=utf-8\"}\n    return self.fetch_json(url, headers)\n</code></pre>"},{"location":"#skg.doi.DOI.doi2bibTex","title":"<code>doi2bibTex()</code>","text":"<p>get the bibtex result for my doi</p> Source code in <code>skg/doi.py</code> <pre><code>def doi2bibTex(self):\n    \"\"\"\n    get the bibtex result for my doi\n    \"\"\"\n    url = f\"https://doi.org/{self.doi}\"\n    headers = {\"Accept\": \"application/x-bibtex; charset=utf-8\"}\n    return self.fetch_text(url, headers)\n</code></pre>"},{"location":"#skg.doi.DOI.fetch_json","title":"<code>fetch_json(url, headers)</code>","text":"<p>fetch json for the given url with the given headers</p> <p>Parameters:</p> Name Type Description Default <code>url(str)</code> <p>the url to fetch the data for</p> required <code>headers(dict)</code> <p>the headers to use</p> required <p>Returns:</p> Name Type Description <code>json</code> <p>json data</p> Source code in <code>skg/doi.py</code> <pre><code>def fetch_json(self, url: str, headers: dict):\n    \"\"\"\n    fetch json for the given url with the given headers\n\n    Args:\n        url(str): the url to fetch the data for\n        headers(dict): the headers to use\n\n    Returns:\n        json: json data\n    \"\"\"\n    # async with aiohttp.ClientSession(headers=headers) as session:\n    #    async with session.get(url) as response:\n    #        return await response.json()\n    text = self.fetch_text(url, headers)\n    json_data = json.loads(text)\n    return json_data\n</code></pre>"},{"location":"#skg.doi.DOI.fetch_response","title":"<code>fetch_response(url, headers)</code>","text":"<p>fetch reponse for the given url with the given headers</p> <p>Parameters:</p> Name Type Description Default <code>url(str)</code> <p>the url to fetch the data for</p> required <code>headers(dict)</code> <p>the headers to use</p> required Source code in <code>skg/doi.py</code> <pre><code>def fetch_response(self, url: str, headers: dict):\n    \"\"\"\n    fetch reponse for the given url with the given headers\n\n    Args:\n        url(str): the url to fetch the data for\n        headers(dict): the headers to use\n    \"\"\"\n    req = urllib.request.Request(url, headers=headers)\n    response = urllib.request.urlopen(req)\n    return response\n</code></pre>"},{"location":"#skg.doi.DOI.fetch_text","title":"<code>fetch_text(url, headers)</code>","text":"<p>fetch text for the given url with the given headers</p> <p>Parameters:</p> Name Type Description Default <code>url(str)</code> <p>the url to fetch the data for</p> required <code>headers(dict)</code> <p>the headers to use</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the text</p> Source code in <code>skg/doi.py</code> <pre><code>def fetch_text(self, url, headers) -&gt; str:\n    \"\"\"\n    fetch text for the given url with the given headers\n\n    Args:\n        url(str): the url to fetch the data for\n        headers(dict): the headers to use\n\n    Returns:\n        str: the text\n    \"\"\"\n    # async with aiohttp.ClientSession(headers=headers) as session:\n    #    async with session.get(url) as response:\n    #        return await response.text()\n    response = self.fetch_response(url, headers)\n    encoding = response.headers.get_content_charset(\"utf-8\")\n    content = response.read()\n    text = content.decode(encoding)\n    return text\n</code></pre>"},{"location":"#skg.doi.DOI.isDOI","title":"<code>isDOI(doi)</code>  <code>classmethod</code>","text":"<p>check that the given string is a doi</p> <p>Parameters:</p> Name Type Description Default <code>doi(str)</code> <p>the potential DOI string</p> required Source code in <code>skg/doi.py</code> <pre><code>@classmethod\ndef isDOI(cls, doi: str):\n    \"\"\"\n    check that the given string is a doi\n\n    Args:\n        doi(str): the potential DOI string\n    \"\"\"\n    if not doi:\n        return False\n    if isinstance(doi, list):\n        ok = len(doi) &gt; 0\n        for single_doi in doi:\n            ok = ok and cls.isDOI(single_doi)\n        return ok\n    if not isinstance(doi, str):\n        return False\n    doi_obj = DOI(doi)\n    return doi_obj.ok\n</code></pre>"},{"location":"#skg.event","title":"<code>event</code>","text":"<p>Created on 2022-11-16</p> <p>@author: wf</p>"},{"location":"#skg.event.Event","title":"<code>Event</code>","text":"<p>               Bases: <code>Node</code></p> <p>an instance of a scientific event</p> Source code in <code>skg/event.py</code> <pre><code>class Event(skg.graph.Node):\n    \"\"\"\n    an instance of a scientific event\n    \"\"\"\n\n    @classmethod\n    def getSamples(cls):\n        samples = [\n            {\n                \"wikiDataId\": \"Q112055391\",\n                \"title\": \"The Third Wikidata Workshop\",\n                \"location\": \"Hangzhou\",\n                \"point_in_time\": \"2022-10-24\",\n                \"official_website\": \"https://wikidataworkshop.github.io/2022/\",\n            }\n        ]\n        return samples\n</code></pre>"},{"location":"#skg.event.EventSeries","title":"<code>EventSeries</code>","text":"<p>               Bases: <code>Node</code></p> <p>an instance of an academic event series</p> Source code in <code>skg/event.py</code> <pre><code>class EventSeries(skg.graph.Node):\n    \"\"\"\n    an instance of an academic event series\n    \"\"\"\n\n    @classmethod\n    def getSamples(cls):\n        samples = [\n            {\"wikiDataId\": \"Q6053150\", \"short_name\": \"ISWC\"},\n            {\n                \"wikiDataId\": \"Q105491257\",\n                \"short_name\": \"ECDL\",\n                \"title\": \"European Conference on Research and Advanced Technology for Digital Libraries (English)\",\n                \"official_website\": \"http://ecdlconference.isti.cnr.it/\",\n            },\n            {\n                \"wikiDataId\": \"Q105695678\",\n                \"short_name\": \"VNC (English)\",\n                \"DBLP_venue_ID\": \"conf/vnc\",\n                \"VIAF_ID\": \"267408611\",\n                \"title\": \"IEEE Vehicular Networking Conference\",\n            },\n            {\n                \"wikiDataId\": \"Q17012957\",\n                \"short_name\": \"ESWC\",\n                \"inception\": \"2004\",\n                \"gndId\": \"1091749205\",\n            },\n        ]\n        return samples\n</code></pre>"},{"location":"#skg.event.Proceedings","title":"<code>Proceedings</code>","text":"<p>               Bases: <code>Node</code></p> <p>Proceedings of an event</p> Source code in <code>skg/event.py</code> <pre><code>class Proceedings(skg.graph.Node):\n    \"\"\"\n    Proceedings of an event\n    \"\"\"\n\n    @classmethod\n    def getSamples(cls):\n        samples = [\n            {\n                \"wikiDataId\": \"Q115053286\",\n                \"short_name\": \"Wikidata 2022 (English)\",\n                \"title\": \"Proceedings of the 3rd Wikidata Workshop 2022 (English)\",\n                \"publication_date\": \"2022-11-03\",\n                \"full_work_available_at_URL\": \"http://ceur-ws.org/Vol-3262/\",\n            }\n        ]\n        return samples\n</code></pre>"},{"location":"#skg.graph","title":"<code>graph</code>","text":"<p>Created on 2022-11-16</p> <p>@author: wf</p>"},{"location":"#skg.graph.Concept","title":"<code>Concept</code>","text":"<p>an Entity</p> Source code in <code>skg/graph.py</code> <pre><code>class Concept:\n    \"\"\"\n    an Entity\n    \"\"\"\n\n    def __init__(self, name: str, cls):\n        \"\"\"\n        constructor\n\n        Args:\n            name(str): the name of the node\n            cls: a class\n        \"\"\"\n        self.name = name\n        self.props = {}\n        self.cls = cls\n        if hasattr(cls, \"getSamples\"):\n            for sample in cls.getSamples():\n                for key in sample.keys():\n                    if not key in self.props:\n                        self.props[key] = Property(self, key)\n\n    def map(self, map_name: str, map_list: list):\n        \"\"\"\n        map the given list of property mappings under the given map_name\n\n        Args:\n            map_name(str): the name of the mapping e.g. \"wikidata\"\n            map_list(list): a list of mapping tuples\n        \"\"\"\n        for prop_name, mapped_prop in map_list:\n            if prop_name in self.props:\n                prop = self.props[prop_name]\n                prop.setmap(map_name, mapped_prop)\n        return self\n\n    def map_wikidata(self, wd_class: str, scholia_suffix, map_list: list):\n        \"\"\"\n        map wikidata entries\n\n        Args:\n            wd_class(str): the main wikidata base class\n            scholia_suffix(str): the scholia suffix\n        \"\"\"\n        self.wd_class = wd_class\n        self.scholia_suffix = scholia_suffix\n        self.map(\"wikidata\", map_list)\n        return self\n</code></pre>"},{"location":"#skg.graph.Concept.__init__","title":"<code>__init__(name, cls)</code>","text":"<p>constructor</p> <p>Parameters:</p> Name Type Description Default <code>name(str)</code> <p>the name of the node</p> required <code>cls</code> <p>a class</p> required Source code in <code>skg/graph.py</code> <pre><code>def __init__(self, name: str, cls):\n    \"\"\"\n    constructor\n\n    Args:\n        name(str): the name of the node\n        cls: a class\n    \"\"\"\n    self.name = name\n    self.props = {}\n    self.cls = cls\n    if hasattr(cls, \"getSamples\"):\n        for sample in cls.getSamples():\n            for key in sample.keys():\n                if not key in self.props:\n                    self.props[key] = Property(self, key)\n</code></pre>"},{"location":"#skg.graph.Concept.map","title":"<code>map(map_name, map_list)</code>","text":"<p>map the given list of property mappings under the given map_name</p> <p>Parameters:</p> Name Type Description Default <code>map_name(str)</code> <p>the name of the mapping e.g. \"wikidata\"</p> required <code>map_list(list)</code> <p>a list of mapping tuples</p> required Source code in <code>skg/graph.py</code> <pre><code>def map(self, map_name: str, map_list: list):\n    \"\"\"\n    map the given list of property mappings under the given map_name\n\n    Args:\n        map_name(str): the name of the mapping e.g. \"wikidata\"\n        map_list(list): a list of mapping tuples\n    \"\"\"\n    for prop_name, mapped_prop in map_list:\n        if prop_name in self.props:\n            prop = self.props[prop_name]\n            prop.setmap(map_name, mapped_prop)\n    return self\n</code></pre>"},{"location":"#skg.graph.Concept.map_wikidata","title":"<code>map_wikidata(wd_class, scholia_suffix, map_list)</code>","text":"<p>map wikidata entries</p> <p>Parameters:</p> Name Type Description Default <code>wd_class(str)</code> <p>the main wikidata base class</p> required <code>scholia_suffix(str)</code> <p>the scholia suffix</p> required Source code in <code>skg/graph.py</code> <pre><code>def map_wikidata(self, wd_class: str, scholia_suffix, map_list: list):\n    \"\"\"\n    map wikidata entries\n\n    Args:\n        wd_class(str): the main wikidata base class\n        scholia_suffix(str): the scholia suffix\n    \"\"\"\n    self.wd_class = wd_class\n    self.scholia_suffix = scholia_suffix\n    self.map(\"wikidata\", map_list)\n    return self\n</code></pre>"},{"location":"#skg.graph.Node","title":"<code>Node</code>","text":"<p>a Node in the scholary knowledge graph</p> Source code in <code>skg/graph.py</code> <pre><code>class Node:\n    \"\"\"\n    a Node in the scholary knowledge graph\n    \"\"\"\n\n    debug = False\n\n    def __init__(self):\n        \"\"\"\n        constructor\n        \"\"\"\n\n    def __str__(self):\n        \"\"\"\n        return a text representation of me\n        \"\"\"\n        text = f\"{self.concept.name} \u279e {self.label}:\"\n        delim = \"\\n  \"\n        for prop in self.concept.props.values():\n            if hasattr(self, prop.name):\n                text += f\"{delim}{prop.name}={getattr(self,prop.name)}\"\n        return text\n\n    def from_dict(self, concept, record: str):\n        \"\"\"\n        get my values from the given record\n        \"\"\"\n        self.concept = concept\n        self.label = record[concept.name]\n        for key in concept.props.keys():\n            if key in record:\n                setattr(self, key, record[key])\n\n    def browser_url(self):\n        \"\"\"\n        get my browser url\n        \"\"\"\n        if self.provenance == \"wikidata\":\n            url = self.scholia_url()\n        else:\n            url = self.label\n        return url\n\n    def scholia_url(self):\n        \"\"\"\n        get my scholia url\n        \"\"\"\n        prefix = f\"https://scholia.toolforge.org/{self.concept.scholia_suffix}\"\n        wd_url = getattr(self, \"wikiDataId\", None)\n        if wd_url is None:\n            return None\n        else:\n            qid = wd_url.replace(\"http://www.wikidata.org/entity/\", \"\")\n            return f\"{prefix}/{qid}\"\n\n    @classmethod\n    def setProvenance(cls, instances: list, provenance: str):\n        \"\"\"\n        set the provenance of the given instances\n        \"\"\"\n        for instance in instances:\n            instance.provenance = provenance\n\n    @classmethod\n    def from_sparql(cls, sparql: SPARQL, sparql_query: str, concept: Concept):\n        \"\"\"\n        get instance from the given sparql access point with the given sparql_query for\n        the given concept\n\n        Args:\n            sparql(SPARQL): the sparql access point\n            sparql_query(str): the query to execute\n            concept(Concept): the concept to create instances for\n        \"\"\"\n        if Node.debug:\n            print(sparql_query)\n        records = sparql.queryAsListOfDicts(sparql_query)\n        instances = cls.from_records(records, concept)\n        return instances\n\n    @classmethod\n    def from_records(cls, records: list, concept: Concept):\n        \"\"\"\n        get instances from the given records for the given concept\n\n        Args:\n            records(list): a list of dicts to get instances for\n            concept(Concept): the concept to create instances for\n        \"\"\"\n        instances = []\n        for record in records:\n            # call my constructor\n            instance = cls()\n            instance.from_dict(concept, record)\n            instances.append(instance)\n        return instances\n\n    @classmethod\n    def from_wikidata_via_id(\n        cls, concept: Concept, id_name: str, id_value: str, lang: str = \"en\"\n    ):\n        \"\"\"\n        get a node instance from wikidata for the given parameters\n\n        Args:\n            concept(Concept): the concept to return\n            id_name(str): the name of the id to search / lookup with\n            id_value(str): the value of the id\n            lang(str): the language code to apply\n        \"\"\"\n        wikidata = Wikidata()\n        if id_name == \"wikiDataId\":\n            value_clause = f\"&lt;http://www.wikidata.org/entity/{id_value}&gt;\"\n        else:\n            value_clause = f'''\"{id_value}\"'''\n        sparql_query = f\"\"\"# Query for {concept.name} details via ID {id_name} value {id_value}\nPREFIX wd: &lt;http://www.wikidata.org/entity/&gt;\nPREFIX wdt: &lt;http://www.wikidata.org/prop/direct/&gt;\nPREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;\nSELECT DISTINCT ?{concept.name} ?qId\"\"\"\n        for prop in concept.props.values():\n            sparql_query += f\" ?{prop.name}\"\n        sparql_query += f\"\"\"\nWHERE {{\n  VALUES ?{id_name} {{\n    {value_clause}\n  }}\n  # classification!\n  ?wikiDataId wdt:P31/wdt:P279* wd:{concept.wd_class}.\n  ?wikiDataId rdfs:label ?{concept.name} .\n  FILTER(LANG(?{concept.name})=\"{lang}\").\n\"\"\"\n        for prop in concept.props.values():\n            if prop.name == \"wikiDataId\":\n                continue\n            if not (prop.hasmap(\"wikidata\")):\n                raise Exception(\n                    f\"Property {prop.name} of {concept.name} has no wikidata mapping\"\n                )\n            wd_prop = prop.getmap(\"wikidata\")\n            clause = f\"?wikiDataId wdt:{wd_prop} ?{prop.name}.\"\n            if prop.name != id_name:\n                clause = f\"OPTIONAL {{ {clause} }}\"\n            sparql_query += \"\\n  \" + clause\n        sparql_query += \"\\n}\"\n        instances = cls.from_sparql(wikidata.sparql, sparql_query, concept)\n        cls.setProvenance(instances, \"wikidata\")\n        return instances\n\n    @classmethod\n    def from_dblp_via_id(\n        cls, concept: Concept, id_name: str, id_value: str, lang: str = \"en\"\n    ):\n        \"\"\"\n        get a node instance from dblp for the given parameters\n\n        Args:\n            concept(Concept): the concept to return\n            id_name(str): the name of the id to search / lookup with\n            id_value(str): the value of the id\n            lang(str): the language code to apply\n        \"\"\"\n        dblp = Dblp()\n        sparql_query = f\"\"\"\nPREFIX dblp: &lt;https://dblp.org/rdf/schema#&gt;\nSELECT \n  ?{concept.name}\"\"\"\n        for prop in concept.props.values():\n            if prop.hasmap(\"dblp\"):\n                sparql_query += f\" ?{prop.name}\"\n        if id_name == \"doi\":\n            value_clause = f\"&lt;http://dx.doi.org/{id_value}&gt;\"\n        elif id_name == \"orcid\":\n            value_clause = f\"&lt;https://orcid.org/{id_value}&gt;\"\n        else:\n            value_clause = f'''\"{id_value}\"'''\n        sparql_query += f\"\"\"\nWHERE {{\n  VALUES ?{id_name} {{\n    {value_clause}\n  }}\n\"\"\"\n        for prop in concept.props.values():\n            if prop.hasmap(\"dblp\"):\n                dblp_prop = prop.getmap(\"dblp\")\n                sparql_query += f\"\"\"?{concept.name} dblp:{dblp_prop} ?{dblp_prop}.\\n\"\"\"\n        sparql_query += \"}\\n\"\n        instances = cls.from_sparql(dblp.sparql, sparql_query, concept)\n        cls.setProvenance(instances, \"dblp\")\n        return instances\n</code></pre>"},{"location":"#skg.graph.Node.__init__","title":"<code>__init__()</code>","text":"<p>constructor</p> Source code in <code>skg/graph.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    constructor\n    \"\"\"\n</code></pre>"},{"location":"#skg.graph.Node.__str__","title":"<code>__str__()</code>","text":"<p>return a text representation of me</p> Source code in <code>skg/graph.py</code> <pre><code>def __str__(self):\n    \"\"\"\n    return a text representation of me\n    \"\"\"\n    text = f\"{self.concept.name} \u279e {self.label}:\"\n    delim = \"\\n  \"\n    for prop in self.concept.props.values():\n        if hasattr(self, prop.name):\n            text += f\"{delim}{prop.name}={getattr(self,prop.name)}\"\n    return text\n</code></pre>"},{"location":"#skg.graph.Node.browser_url","title":"<code>browser_url()</code>","text":"<p>get my browser url</p> Source code in <code>skg/graph.py</code> <pre><code>def browser_url(self):\n    \"\"\"\n    get my browser url\n    \"\"\"\n    if self.provenance == \"wikidata\":\n        url = self.scholia_url()\n    else:\n        url = self.label\n    return url\n</code></pre>"},{"location":"#skg.graph.Node.from_dblp_via_id","title":"<code>from_dblp_via_id(concept, id_name, id_value, lang='en')</code>  <code>classmethod</code>","text":"<p>get a node instance from dblp for the given parameters</p> <p>Parameters:</p> Name Type Description Default <code>concept(Concept)</code> <p>the concept to return</p> required <code>id_name(str)</code> <p>the name of the id to search / lookup with</p> required <code>id_value(str)</code> <p>the value of the id</p> required <code>lang(str)</code> <p>the language code to apply</p> required Source code in <code>skg/graph.py</code> <pre><code>    @classmethod\n    def from_dblp_via_id(\n        cls, concept: Concept, id_name: str, id_value: str, lang: str = \"en\"\n    ):\n        \"\"\"\n        get a node instance from dblp for the given parameters\n\n        Args:\n            concept(Concept): the concept to return\n            id_name(str): the name of the id to search / lookup with\n            id_value(str): the value of the id\n            lang(str): the language code to apply\n        \"\"\"\n        dblp = Dblp()\n        sparql_query = f\"\"\"\nPREFIX dblp: &lt;https://dblp.org/rdf/schema#&gt;\nSELECT \n  ?{concept.name}\"\"\"\n        for prop in concept.props.values():\n            if prop.hasmap(\"dblp\"):\n                sparql_query += f\" ?{prop.name}\"\n        if id_name == \"doi\":\n            value_clause = f\"&lt;http://dx.doi.org/{id_value}&gt;\"\n        elif id_name == \"orcid\":\n            value_clause = f\"&lt;https://orcid.org/{id_value}&gt;\"\n        else:\n            value_clause = f'''\"{id_value}\"'''\n        sparql_query += f\"\"\"\nWHERE {{\n  VALUES ?{id_name} {{\n    {value_clause}\n  }}\n\"\"\"\n        for prop in concept.props.values():\n            if prop.hasmap(\"dblp\"):\n                dblp_prop = prop.getmap(\"dblp\")\n                sparql_query += f\"\"\"?{concept.name} dblp:{dblp_prop} ?{dblp_prop}.\\n\"\"\"\n        sparql_query += \"}\\n\"\n        instances = cls.from_sparql(dblp.sparql, sparql_query, concept)\n        cls.setProvenance(instances, \"dblp\")\n        return instances\n</code></pre>"},{"location":"#skg.graph.Node.from_dict","title":"<code>from_dict(concept, record)</code>","text":"<p>get my values from the given record</p> Source code in <code>skg/graph.py</code> <pre><code>def from_dict(self, concept, record: str):\n    \"\"\"\n    get my values from the given record\n    \"\"\"\n    self.concept = concept\n    self.label = record[concept.name]\n    for key in concept.props.keys():\n        if key in record:\n            setattr(self, key, record[key])\n</code></pre>"},{"location":"#skg.graph.Node.from_records","title":"<code>from_records(records, concept)</code>  <code>classmethod</code>","text":"<p>get instances from the given records for the given concept</p> <p>Parameters:</p> Name Type Description Default <code>records(list)</code> <p>a list of dicts to get instances for</p> required <code>concept(Concept)</code> <p>the concept to create instances for</p> required Source code in <code>skg/graph.py</code> <pre><code>@classmethod\ndef from_records(cls, records: list, concept: Concept):\n    \"\"\"\n    get instances from the given records for the given concept\n\n    Args:\n        records(list): a list of dicts to get instances for\n        concept(Concept): the concept to create instances for\n    \"\"\"\n    instances = []\n    for record in records:\n        # call my constructor\n        instance = cls()\n        instance.from_dict(concept, record)\n        instances.append(instance)\n    return instances\n</code></pre>"},{"location":"#skg.graph.Node.from_sparql","title":"<code>from_sparql(sparql, sparql_query, concept)</code>  <code>classmethod</code>","text":"<p>get instance from the given sparql access point with the given sparql_query for the given concept</p> <p>Parameters:</p> Name Type Description Default <code>sparql(SPARQL)</code> <p>the sparql access point</p> required <code>sparql_query(str)</code> <p>the query to execute</p> required <code>concept(Concept)</code> <p>the concept to create instances for</p> required Source code in <code>skg/graph.py</code> <pre><code>@classmethod\ndef from_sparql(cls, sparql: SPARQL, sparql_query: str, concept: Concept):\n    \"\"\"\n    get instance from the given sparql access point with the given sparql_query for\n    the given concept\n\n    Args:\n        sparql(SPARQL): the sparql access point\n        sparql_query(str): the query to execute\n        concept(Concept): the concept to create instances for\n    \"\"\"\n    if Node.debug:\n        print(sparql_query)\n    records = sparql.queryAsListOfDicts(sparql_query)\n    instances = cls.from_records(records, concept)\n    return instances\n</code></pre>"},{"location":"#skg.graph.Node.from_wikidata_via_id","title":"<code>from_wikidata_via_id(concept, id_name, id_value, lang='en')</code>  <code>classmethod</code>","text":"<p>get a node instance from wikidata for the given parameters</p> <p>Parameters:</p> Name Type Description Default <code>concept(Concept)</code> <p>the concept to return</p> required <code>id_name(str)</code> <p>the name of the id to search / lookup with</p> required <code>id_value(str)</code> <p>the value of the id</p> required <code>lang(str)</code> <p>the language code to apply</p> required Source code in <code>skg/graph.py</code> <pre><code>    @classmethod\n    def from_wikidata_via_id(\n        cls, concept: Concept, id_name: str, id_value: str, lang: str = \"en\"\n    ):\n        \"\"\"\n        get a node instance from wikidata for the given parameters\n\n        Args:\n            concept(Concept): the concept to return\n            id_name(str): the name of the id to search / lookup with\n            id_value(str): the value of the id\n            lang(str): the language code to apply\n        \"\"\"\n        wikidata = Wikidata()\n        if id_name == \"wikiDataId\":\n            value_clause = f\"&lt;http://www.wikidata.org/entity/{id_value}&gt;\"\n        else:\n            value_clause = f'''\"{id_value}\"'''\n        sparql_query = f\"\"\"# Query for {concept.name} details via ID {id_name} value {id_value}\nPREFIX wd: &lt;http://www.wikidata.org/entity/&gt;\nPREFIX wdt: &lt;http://www.wikidata.org/prop/direct/&gt;\nPREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;\nSELECT DISTINCT ?{concept.name} ?qId\"\"\"\n        for prop in concept.props.values():\n            sparql_query += f\" ?{prop.name}\"\n        sparql_query += f\"\"\"\nWHERE {{\n  VALUES ?{id_name} {{\n    {value_clause}\n  }}\n  # classification!\n  ?wikiDataId wdt:P31/wdt:P279* wd:{concept.wd_class}.\n  ?wikiDataId rdfs:label ?{concept.name} .\n  FILTER(LANG(?{concept.name})=\"{lang}\").\n\"\"\"\n        for prop in concept.props.values():\n            if prop.name == \"wikiDataId\":\n                continue\n            if not (prop.hasmap(\"wikidata\")):\n                raise Exception(\n                    f\"Property {prop.name} of {concept.name} has no wikidata mapping\"\n                )\n            wd_prop = prop.getmap(\"wikidata\")\n            clause = f\"?wikiDataId wdt:{wd_prop} ?{prop.name}.\"\n            if prop.name != id_name:\n                clause = f\"OPTIONAL {{ {clause} }}\"\n            sparql_query += \"\\n  \" + clause\n        sparql_query += \"\\n}\"\n        instances = cls.from_sparql(wikidata.sparql, sparql_query, concept)\n        cls.setProvenance(instances, \"wikidata\")\n        return instances\n</code></pre>"},{"location":"#skg.graph.Node.scholia_url","title":"<code>scholia_url()</code>","text":"<p>get my scholia url</p> Source code in <code>skg/graph.py</code> <pre><code>def scholia_url(self):\n    \"\"\"\n    get my scholia url\n    \"\"\"\n    prefix = f\"https://scholia.toolforge.org/{self.concept.scholia_suffix}\"\n    wd_url = getattr(self, \"wikiDataId\", None)\n    if wd_url is None:\n        return None\n    else:\n        qid = wd_url.replace(\"http://www.wikidata.org/entity/\", \"\")\n        return f\"{prefix}/{qid}\"\n</code></pre>"},{"location":"#skg.graph.Node.setProvenance","title":"<code>setProvenance(instances, provenance)</code>  <code>classmethod</code>","text":"<p>set the provenance of the given instances</p> Source code in <code>skg/graph.py</code> <pre><code>@classmethod\ndef setProvenance(cls, instances: list, provenance: str):\n    \"\"\"\n    set the provenance of the given instances\n    \"\"\"\n    for instance in instances:\n        instance.provenance = provenance\n</code></pre>"},{"location":"#skg.graph.Property","title":"<code>Property</code>","text":"<p>a Property</p> Source code in <code>skg/graph.py</code> <pre><code>class Property:\n    \"\"\"\n    a Property\n    \"\"\"\n\n    def __init__(self, concept: Concept, name: str):\n        \"\"\"\n        constructor\n\n        Args:\n            concept(Concept): the concept this property belongs to\n            name(str): the name of the property\n\n        \"\"\"\n        self.concept = concept\n        self.name = name\n        self.maps = {}\n\n    def setmap(self, map_name, mapped_prop):\n        \"\"\"\n        map the given property\n        \"\"\"\n        self.maps[map_name] = mapped_prop\n\n    def getmap(self, map_name):\n        return self.maps[map_name]\n\n    def hasmap(self, map_name: str) -&gt; bool:\n        \"\"\"\n        check whether there is a mapping for the given map_name\n\n        Args:\n            map_name(str): the map name to check\n\n        Returns:\n            bool: True if there is mapping\n        \"\"\"\n        return map_name in self.maps\n</code></pre>"},{"location":"#skg.graph.Property.__init__","title":"<code>__init__(concept, name)</code>","text":"<p>constructor</p> <p>Parameters:</p> Name Type Description Default <code>concept(Concept)</code> <p>the concept this property belongs to</p> required <code>name(str)</code> <p>the name of the property</p> required Source code in <code>skg/graph.py</code> <pre><code>def __init__(self, concept: Concept, name: str):\n    \"\"\"\n    constructor\n\n    Args:\n        concept(Concept): the concept this property belongs to\n        name(str): the name of the property\n\n    \"\"\"\n    self.concept = concept\n    self.name = name\n    self.maps = {}\n</code></pre>"},{"location":"#skg.graph.Property.hasmap","title":"<code>hasmap(map_name)</code>","text":"<p>check whether there is a mapping for the given map_name</p> <p>Parameters:</p> Name Type Description Default <code>map_name(str)</code> <p>the map name to check</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if there is mapping</p> Source code in <code>skg/graph.py</code> <pre><code>def hasmap(self, map_name: str) -&gt; bool:\n    \"\"\"\n    check whether there is a mapping for the given map_name\n\n    Args:\n        map_name(str): the map name to check\n\n    Returns:\n        bool: True if there is mapping\n    \"\"\"\n    return map_name in self.maps\n</code></pre>"},{"location":"#skg.graph.Property.setmap","title":"<code>setmap(map_name, mapped_prop)</code>","text":"<p>map the given property</p> Source code in <code>skg/graph.py</code> <pre><code>def setmap(self, map_name, mapped_prop):\n    \"\"\"\n    map the given property\n    \"\"\"\n    self.maps[map_name] = mapped_prop\n</code></pre>"},{"location":"#skg.kg","title":"<code>kg</code>","text":"<p>Created on 2022-11-16</p> <p>@author: wf</p>"},{"location":"#skg.kg.SKG_Def","title":"<code>SKG_Def</code>","text":"<p>scholary knowledge graph</p> Source code in <code>skg/kg.py</code> <pre><code>class SKG_Def:\n    \"\"\"\n    scholary knowledge graph\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        constructor\n        \"\"\"\n        self.concepts = {\n            # main concepts\n            \"Scholar\": Concept(name=\"Scholar\", cls=Scholar),\n            \"Institution\": Concept(name=\"Institution\", cls=Institution),\n            \"Paper\": Concept(name=\"Paper\", cls=Paper),\n            \"Event\": Concept(name=\"Event\", cls=Event),\n            \"EventSeries\": Concept(name=\"EventSeries\", cls=EventSeries),\n            \"Proceedings\": Concept(name=\"Proceedings\", cls=Proceedings),\n            # neighbour concepts\n            \"Country\": Concept(name=\"Country\", cls=Country),\n        }\n        self.concepts[\"Scholar\"].map_wikidata(\n            \"Q5\",\n            \"author\",\n            [\n                (\"name\", \"label\"),\n                (\"dblpId\", \"P2456\"),\n                (\"gndId\", \"P227\"),\n                (\"linkedInId\", \"P6634\"),\n                (\"homepage\", \"P856\"),\n                (\"googleScholarUser\", \"P1960\"),\n                (\"orcid\", \"P496\"),\n                (\"givenName\", \"P735\"),\n                (\"familyName\", \"P734\"),\n                (\"gender\", \"P21\"),\n                (\"image\", \"P18\"),\n                (\"occupation\", \"P106\"),\n                (\"Semantic_Scholar_author_ID\", \"P4012\"),\n            ],\n        ).map(\n            \"dblp\",\n            [\n                (\"name\", \"primaryCreatorName\"),\n                (\"homepage\", \"primaryHomepage\"),\n                (\"orcid\", \"orcid\"),\n            ],\n        ).map(\n            \"smw\",\n            [\n                (\"wikiDataId\", \"wikiDataId\"),\n                (\"familyName\", \"name\"),\n                (\"givenName\", \"firstName\"),\n                (\"googleScholarUser\", \"googleScholarUser\"),\n                (\"homepage\", \"homepage\"),\n                (\"dblpId\", \"dblpId\"),\n                (\"orcid\", \"orcid\"),\n                (\"linkedInId\", \"linkedInId\"),\n            ],\n        )\n        self.concepts[\"Institution\"].map_wikidata(\n            \"Q4671277\",\n            \"organization\",\n            [\n                (\"short_name\", \"P1813\"),  # 2.0 %\n                (\"inception\", \"P571\"),  # 65.8 %\n                (\"image\", \"P18\"),  # 15.2 %\n                (\"country\", \"P17\"),  # 88.8 %\n                (\"located_in\", \"P131\"),  # 51.9 %\n                (\"official_website\", \"P856\"),  # 59.1%\n                (\"coordinate_location\", \"P625\"),  # 44.0 %\n            ],\n        )\n        self.concepts[\"Paper\"].map_wikidata(\n            \"Q13442814\",\n            \"work\",\n            [\n                (\"title\", \"label\"),\n                (\"doi\", \"P356\"),\n                (\"DBLP_publication_ID\", \"P8978\"),\n                (\"publication_date\", \"P577\"),\n            ],\n        ).map(\"dblp\", [(\"title\", \"title\"), (\"doi\", \"doi\")])\n        # scientific event\n        self.concepts[\"Event\"].map_wikidata(\n            \"Q52260246\",\n            \"event\",\n            [\n                (\"title\", \"P1476\"),\n                (\"country\", \"P17\"),  # 93.9% -&gt; Human Settlement\n                (\"location\", \"P276\"),  # 94.6%\n                (\"point_in_time\", \"P585\"),\n                (\"official_website\", \"P856\"),\n            ],\n        )\n        # academic event series\n        self.concepts[\"EventSeries\"].map_wikidata(\n            \"Q47258130\",\n            \"event-series\",\n            [\n                (\"title\", \"P1476\"),  # 96.7 %\n                (\"short_name\", \"P1813\"),  # 93.1 %\n                (\"VIAF_ID\", \"P214\"),  # 60.5 %\n                (\"DBLP_venue_ID\", \"P8926\"),  # 96.4 %\n                (\"gndId\", \"P227\"),  # 42.3 %\n                (\"inception\", \"P571\"),  # 22.3 %\n                (\"official_website\", \"P856\"),  # 13.5 %\n            ],\n        )\n        # proceedings\n        self.concepts[\"Proceedings\"].map_wikidata(\n            \"Q1143604\",\n            \"venue\",\n            [\n                (\"title\", \"P1476\"),\n                (\"short_name\", \"P1813\"),\n                (\"full_work_available_at_URL\", \"P953\"),\n                (\"publication_date\", \"P577\"),\n            ],\n        )\n        # country\n        self.concepts[\"Country\"].map_wikidata(\n            \"Q6256\",\n            \"topic\",\n            [\n                (\"name\", \"label\"),  # 100% ?\n                (\"homepage\", \"P856\"),  # 49.4%\n                (\"population\", \"P1082\"),  # 57.4%\n                (\"capital\", \"P36\"),  # 59.8%\n                (\"coordinate_location\", \"P625\"),  # 58.6%\n                (\"iso_code\", \"P297\"),  # 53.3%\n            ],\n        )\n\n        self.concepts_by_qid = {}\n        for concept in self.concepts.values():\n            if concept.wd_class in self.concepts_by_qid:\n                raise Exception(f\"duplicate wd_class definition: {concept.wd_class}\")\n            self.concepts_by_qid[concept.wd_class] = concept\n\n    def conceptForQid(self, qid: str) -&gt; Concept:\n        \"\"\"\n        get the concept for the given wikidata Q Identifieer\n\n        Args:\n            qid(str): get the concept for the given Qid\n\n        Return:\n            Concept: or None if none is found\n        \"\"\"\n        concept = self.concepts_by_qid.get(qid, None)\n        return concept\n\n    def toPlantuml(self, header: str = None, footer: str = None) -&gt; str:\n        \"\"\"\n        get a plantuml version of this knowledge graph\n\n        Args:\n            header(str): the header to apply\n            footer(str): the footer to apply\n\n        Returns:\n            str: the plantuml markup\n\n        \"\"\"\n        timestamp = datetime.datetime.utcnow().strftime(\"%Y-%m-%d\")\n        if header is None:\n            header = f\"\"\"/'{Version.name}:{Version.description}\nupdated {timestamp}\n\nauthors:{Version.authors} \n'/\ntitle  {Version.name}:{Version.description} see {Version.doc_url} updated {timestamp}\nhide circle\npackage skg {{\n\"\"\"\n        if footer is None:\n            footer = \"}\\n\"\n        markup = f\"{header}\"\n        indent = \"  \"\n        for concept_name, concept in self.concepts.items():\n            markup += f\"\"\"{indent}class {concept_name} {{\\n\"\"\"\n            for prop_name, prop in concept.props.items():\n                markup += f\"\"\"{indent}  {prop_name}\\n\"\"\"\n            markup += f\"\"\"\\n{indent}}}\\n\"\"\"\n        markup += f\"{footer}\"\n        return markup\n\n    def toSiDiF(self) -&gt; str:\n        \"\"\"\n        convert me to SiDiF format\n        \"\"\"\n        sidif = \"\"\n        for concept_name, concept in self.concepts.items():\n            sidif += f\"\"\"#\n# {concept_name}\n#\n{concept_name} isA Topic\n\"{concept_name} is name of it\n\"\"\"\n        return sidif\n</code></pre>"},{"location":"#skg.kg.SKG_Def.__init__","title":"<code>__init__()</code>","text":"<p>constructor</p> Source code in <code>skg/kg.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    constructor\n    \"\"\"\n    self.concepts = {\n        # main concepts\n        \"Scholar\": Concept(name=\"Scholar\", cls=Scholar),\n        \"Institution\": Concept(name=\"Institution\", cls=Institution),\n        \"Paper\": Concept(name=\"Paper\", cls=Paper),\n        \"Event\": Concept(name=\"Event\", cls=Event),\n        \"EventSeries\": Concept(name=\"EventSeries\", cls=EventSeries),\n        \"Proceedings\": Concept(name=\"Proceedings\", cls=Proceedings),\n        # neighbour concepts\n        \"Country\": Concept(name=\"Country\", cls=Country),\n    }\n    self.concepts[\"Scholar\"].map_wikidata(\n        \"Q5\",\n        \"author\",\n        [\n            (\"name\", \"label\"),\n            (\"dblpId\", \"P2456\"),\n            (\"gndId\", \"P227\"),\n            (\"linkedInId\", \"P6634\"),\n            (\"homepage\", \"P856\"),\n            (\"googleScholarUser\", \"P1960\"),\n            (\"orcid\", \"P496\"),\n            (\"givenName\", \"P735\"),\n            (\"familyName\", \"P734\"),\n            (\"gender\", \"P21\"),\n            (\"image\", \"P18\"),\n            (\"occupation\", \"P106\"),\n            (\"Semantic_Scholar_author_ID\", \"P4012\"),\n        ],\n    ).map(\n        \"dblp\",\n        [\n            (\"name\", \"primaryCreatorName\"),\n            (\"homepage\", \"primaryHomepage\"),\n            (\"orcid\", \"orcid\"),\n        ],\n    ).map(\n        \"smw\",\n        [\n            (\"wikiDataId\", \"wikiDataId\"),\n            (\"familyName\", \"name\"),\n            (\"givenName\", \"firstName\"),\n            (\"googleScholarUser\", \"googleScholarUser\"),\n            (\"homepage\", \"homepage\"),\n            (\"dblpId\", \"dblpId\"),\n            (\"orcid\", \"orcid\"),\n            (\"linkedInId\", \"linkedInId\"),\n        ],\n    )\n    self.concepts[\"Institution\"].map_wikidata(\n        \"Q4671277\",\n        \"organization\",\n        [\n            (\"short_name\", \"P1813\"),  # 2.0 %\n            (\"inception\", \"P571\"),  # 65.8 %\n            (\"image\", \"P18\"),  # 15.2 %\n            (\"country\", \"P17\"),  # 88.8 %\n            (\"located_in\", \"P131\"),  # 51.9 %\n            (\"official_website\", \"P856\"),  # 59.1%\n            (\"coordinate_location\", \"P625\"),  # 44.0 %\n        ],\n    )\n    self.concepts[\"Paper\"].map_wikidata(\n        \"Q13442814\",\n        \"work\",\n        [\n            (\"title\", \"label\"),\n            (\"doi\", \"P356\"),\n            (\"DBLP_publication_ID\", \"P8978\"),\n            (\"publication_date\", \"P577\"),\n        ],\n    ).map(\"dblp\", [(\"title\", \"title\"), (\"doi\", \"doi\")])\n    # scientific event\n    self.concepts[\"Event\"].map_wikidata(\n        \"Q52260246\",\n        \"event\",\n        [\n            (\"title\", \"P1476\"),\n            (\"country\", \"P17\"),  # 93.9% -&gt; Human Settlement\n            (\"location\", \"P276\"),  # 94.6%\n            (\"point_in_time\", \"P585\"),\n            (\"official_website\", \"P856\"),\n        ],\n    )\n    # academic event series\n    self.concepts[\"EventSeries\"].map_wikidata(\n        \"Q47258130\",\n        \"event-series\",\n        [\n            (\"title\", \"P1476\"),  # 96.7 %\n            (\"short_name\", \"P1813\"),  # 93.1 %\n            (\"VIAF_ID\", \"P214\"),  # 60.5 %\n            (\"DBLP_venue_ID\", \"P8926\"),  # 96.4 %\n            (\"gndId\", \"P227\"),  # 42.3 %\n            (\"inception\", \"P571\"),  # 22.3 %\n            (\"official_website\", \"P856\"),  # 13.5 %\n        ],\n    )\n    # proceedings\n    self.concepts[\"Proceedings\"].map_wikidata(\n        \"Q1143604\",\n        \"venue\",\n        [\n            (\"title\", \"P1476\"),\n            (\"short_name\", \"P1813\"),\n            (\"full_work_available_at_URL\", \"P953\"),\n            (\"publication_date\", \"P577\"),\n        ],\n    )\n    # country\n    self.concepts[\"Country\"].map_wikidata(\n        \"Q6256\",\n        \"topic\",\n        [\n            (\"name\", \"label\"),  # 100% ?\n            (\"homepage\", \"P856\"),  # 49.4%\n            (\"population\", \"P1082\"),  # 57.4%\n            (\"capital\", \"P36\"),  # 59.8%\n            (\"coordinate_location\", \"P625\"),  # 58.6%\n            (\"iso_code\", \"P297\"),  # 53.3%\n        ],\n    )\n\n    self.concepts_by_qid = {}\n    for concept in self.concepts.values():\n        if concept.wd_class in self.concepts_by_qid:\n            raise Exception(f\"duplicate wd_class definition: {concept.wd_class}\")\n        self.concepts_by_qid[concept.wd_class] = concept\n</code></pre>"},{"location":"#skg.kg.SKG_Def.conceptForQid","title":"<code>conceptForQid(qid)</code>","text":"<p>get the concept for the given wikidata Q Identifieer</p> <p>Parameters:</p> Name Type Description Default <code>qid(str)</code> <p>get the concept for the given Qid</p> required Return <p>Concept: or None if none is found</p> Source code in <code>skg/kg.py</code> <pre><code>def conceptForQid(self, qid: str) -&gt; Concept:\n    \"\"\"\n    get the concept for the given wikidata Q Identifieer\n\n    Args:\n        qid(str): get the concept for the given Qid\n\n    Return:\n        Concept: or None if none is found\n    \"\"\"\n    concept = self.concepts_by_qid.get(qid, None)\n    return concept\n</code></pre>"},{"location":"#skg.kg.SKG_Def.toPlantuml","title":"<code>toPlantuml(header=None, footer=None)</code>","text":"<p>get a plantuml version of this knowledge graph</p> <p>Parameters:</p> Name Type Description Default <code>header(str)</code> <p>the header to apply</p> required <code>footer(str)</code> <p>the footer to apply</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the plantuml markup</p> Source code in <code>skg/kg.py</code> <pre><code>    def toPlantuml(self, header: str = None, footer: str = None) -&gt; str:\n        \"\"\"\n        get a plantuml version of this knowledge graph\n\n        Args:\n            header(str): the header to apply\n            footer(str): the footer to apply\n\n        Returns:\n            str: the plantuml markup\n\n        \"\"\"\n        timestamp = datetime.datetime.utcnow().strftime(\"%Y-%m-%d\")\n        if header is None:\n            header = f\"\"\"/'{Version.name}:{Version.description}\nupdated {timestamp}\n\nauthors:{Version.authors} \n'/\ntitle  {Version.name}:{Version.description} see {Version.doc_url} updated {timestamp}\nhide circle\npackage skg {{\n\"\"\"\n        if footer is None:\n            footer = \"}\\n\"\n        markup = f\"{header}\"\n        indent = \"  \"\n        for concept_name, concept in self.concepts.items():\n            markup += f\"\"\"{indent}class {concept_name} {{\\n\"\"\"\n            for prop_name, prop in concept.props.items():\n                markup += f\"\"\"{indent}  {prop_name}\\n\"\"\"\n            markup += f\"\"\"\\n{indent}}}\\n\"\"\"\n        markup += f\"{footer}\"\n        return markup\n</code></pre>"},{"location":"#skg.kg.SKG_Def.toSiDiF","title":"<code>toSiDiF()</code>","text":"<p>convert me to SiDiF format</p> Source code in <code>skg/kg.py</code> <pre><code>    def toSiDiF(self) -&gt; str:\n        \"\"\"\n        convert me to SiDiF format\n        \"\"\"\n        sidif = \"\"\n        for concept_name, concept in self.concepts.items():\n            sidif += f\"\"\"#\n# {concept_name}\n#\n{concept_name} isA Topic\n\"{concept_name} is name of it\n\"\"\"\n        return sidif\n</code></pre>"},{"location":"#skg.location","title":"<code>location</code>","text":"<p>Created on 2022-11-21</p> <p>@author: wf</p>"},{"location":"#skg.location.Country","title":"<code>Country</code>","text":"<p>               Bases: <code>Node</code></p> <p>an instance of a country</p> Source code in <code>skg/location.py</code> <pre><code>class Country(skg.graph.Node):\n    \"\"\"\n    an instance of a country\n    \"\"\"\n\n    @classmethod\n    def getSamples(cls):\n        samples = [\n            {\n                \"wikiDataId\": \"Q334\",\n                \"name\": \"Singapore\",\n                \"iso_code\": \"SG\",\n                \"homepage\": \"https://www.gov.sg/\",\n                \"population\": 5866139,\n                \"coordinate_location\": \"1\u00b018'N, 103\u00b048'E\",\n            }\n        ]\n        return samples\n</code></pre>"},{"location":"#skg.orcid","title":"<code>orcid</code>","text":"<p>Created on 2022-11-19</p> <p>@author: wf</p>"},{"location":"#skg.orcid.ORCID","title":"<code>ORCID</code>","text":"<p>ORCID handling</p> <p>see e.g.     https://info.orcid.org/brand-guidelines/#h-orcid-logos-and-icons     https://pub.orcid.org/v3.0/</p> Source code in <code>skg/orcid.py</code> <pre><code>class ORCID:\n    \"\"\"\n    ORCID handling\n\n    see e.g.\n        https://info.orcid.org/brand-guidelines/#h-orcid-logos-and-icons\n        https://pub.orcid.org/v3.0/\n    \"\"\"\n\n    pattern = re.compile(r\"^(\\d{4}-){3}\\d{3}(\\d|X)$\")\n\n    def __init__(self, orcid: str):\n        \"\"\"\n        constructor\n\n        Args:\n            orcid(str): the orcid\n        \"\"\"\n        self.orcid = orcid\n        # https://support.orcid.org/hc/en-us/articles/360006897674-Structure-of-the-ORCID-Identifier\n        self.orcid_num = orcid.replace(\"-\", \"\")\n        match = re.match(ORCID.pattern, orcid)\n        self.ok = bool(match) and validate(self.orcid_num)\n\n    @classmethod\n    def isORCID(cls, orcid: str) -&gt; bool:\n        \"\"\"\n        check that the given string is an ORCID\n\n        Args:\n            orcid(str): the potential ORCID string\n\n        Returns:\n            bool: True if the string represents a valid ORCID otherwise false\n        \"\"\"\n        if not orcid:\n            return False\n        orcid_obj = ORCID(orcid)\n        return orcid_obj.ok\n\n    def getMetadata(self, op: str = None) -&gt; dict:\n        \"\"\"\n        get the ORCID metadata data\n\n        Args:\n            op(str): the https://pub.orcid.org/v3.0/ API\n            operation to apply - default is \"Fetch record details\"\n\n        Returns:\n            dict: the dictionary derived from the JSON response\n\n        \"\"\"\n        op = \"\" if op is None else f\"/{op}\"\n        url = f\"https://pub.orcid.org/v3.0/{self.orcid}{op}\"\n        r = requests.get(\n            url, headers={\"User-Agent\": \"Mozilla/5.0\", \"accept\": \"application/json\"}\n        )\n        json_data = r.json()\n        return json_data\n\n    def asHtml(self, mode: str = \"full\", inline: str = \"\") -&gt; str:\n        \"\"\"\n        the orcid logo\n\n        Args:\n            mode(str): the mode\n            inline(str): in inline mode this is the text to be displayed inline\n\n        Returns:\n            str: the html code\n\n        \"\"\"\n        href = f\"\"\"https://orcid.org/{self.orcid}\"\"\"\n        logo = \"\"\"&lt;img alt=\"ORCID logo\" src=\"https://info.orcid.org/wp-content/uploads/2019/11/orcid_16x16.png\" width=\"16\" height=\"16\" /&gt;\"\"\"\n        if mode == \"full\":\n            html = f\"\"\"&lt;a href=\"{href}\"&gt;{logo}{href}&lt;/a&gt;\"\"\"\n        elif mode == \"compact\":\n            html = f\"\"\"&lt;a href=\"{href}\"&gt;{logo}{self.orcid}&lt;/a&gt;\"\"\"\n        elif mode == \"inline\":\n            html = f\"\"\"&lt;a href=\"{href}\"&gt;{inline}{logo}&lt;/a&gt;\"\"\"\n        return html\n</code></pre>"},{"location":"#skg.orcid.ORCID.__init__","title":"<code>__init__(orcid)</code>","text":"<p>constructor</p> <p>Parameters:</p> Name Type Description Default <code>orcid(str)</code> <p>the orcid</p> required Source code in <code>skg/orcid.py</code> <pre><code>def __init__(self, orcid: str):\n    \"\"\"\n    constructor\n\n    Args:\n        orcid(str): the orcid\n    \"\"\"\n    self.orcid = orcid\n    # https://support.orcid.org/hc/en-us/articles/360006897674-Structure-of-the-ORCID-Identifier\n    self.orcid_num = orcid.replace(\"-\", \"\")\n    match = re.match(ORCID.pattern, orcid)\n    self.ok = bool(match) and validate(self.orcid_num)\n</code></pre>"},{"location":"#skg.orcid.ORCID.asHtml","title":"<code>asHtml(mode='full', inline='')</code>","text":"<p>the orcid logo</p> <p>Parameters:</p> Name Type Description Default <code>mode(str)</code> <p>the mode</p> required <code>inline(str)</code> <p>in inline mode this is the text to be displayed inline</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the html code</p> Source code in <code>skg/orcid.py</code> <pre><code>def asHtml(self, mode: str = \"full\", inline: str = \"\") -&gt; str:\n    \"\"\"\n    the orcid logo\n\n    Args:\n        mode(str): the mode\n        inline(str): in inline mode this is the text to be displayed inline\n\n    Returns:\n        str: the html code\n\n    \"\"\"\n    href = f\"\"\"https://orcid.org/{self.orcid}\"\"\"\n    logo = \"\"\"&lt;img alt=\"ORCID logo\" src=\"https://info.orcid.org/wp-content/uploads/2019/11/orcid_16x16.png\" width=\"16\" height=\"16\" /&gt;\"\"\"\n    if mode == \"full\":\n        html = f\"\"\"&lt;a href=\"{href}\"&gt;{logo}{href}&lt;/a&gt;\"\"\"\n    elif mode == \"compact\":\n        html = f\"\"\"&lt;a href=\"{href}\"&gt;{logo}{self.orcid}&lt;/a&gt;\"\"\"\n    elif mode == \"inline\":\n        html = f\"\"\"&lt;a href=\"{href}\"&gt;{inline}{logo}&lt;/a&gt;\"\"\"\n    return html\n</code></pre>"},{"location":"#skg.orcid.ORCID.getMetadata","title":"<code>getMetadata(op=None)</code>","text":"<p>get the ORCID metadata data</p> <p>Parameters:</p> Name Type Description Default <code>op(str)</code> <p>the https://pub.orcid.org/v3.0/ API</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>the dictionary derived from the JSON response</p> Source code in <code>skg/orcid.py</code> <pre><code>def getMetadata(self, op: str = None) -&gt; dict:\n    \"\"\"\n    get the ORCID metadata data\n\n    Args:\n        op(str): the https://pub.orcid.org/v3.0/ API\n        operation to apply - default is \"Fetch record details\"\n\n    Returns:\n        dict: the dictionary derived from the JSON response\n\n    \"\"\"\n    op = \"\" if op is None else f\"/{op}\"\n    url = f\"https://pub.orcid.org/v3.0/{self.orcid}{op}\"\n    r = requests.get(\n        url, headers={\"User-Agent\": \"Mozilla/5.0\", \"accept\": \"application/json\"}\n    )\n    json_data = r.json()\n    return json_data\n</code></pre>"},{"location":"#skg.orcid.ORCID.isORCID","title":"<code>isORCID(orcid)</code>  <code>classmethod</code>","text":"<p>check that the given string is an ORCID</p> <p>Parameters:</p> Name Type Description Default <code>orcid(str)</code> <p>the potential ORCID string</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the string represents a valid ORCID otherwise false</p> Source code in <code>skg/orcid.py</code> <pre><code>@classmethod\ndef isORCID(cls, orcid: str) -&gt; bool:\n    \"\"\"\n    check that the given string is an ORCID\n\n    Args:\n        orcid(str): the potential ORCID string\n\n    Returns:\n        bool: True if the string represents a valid ORCID otherwise false\n    \"\"\"\n    if not orcid:\n        return False\n    orcid_obj = ORCID(orcid)\n    return orcid_obj.ok\n</code></pre>"},{"location":"#skg.owl","title":"<code>owl</code>","text":"<p>Created on 2022-11-22</p> <p>@author: wf</p>"},{"location":"#skg.owl.Owl","title":"<code>Owl</code>","text":"<p>               Bases: <code>Schema</code></p> <p>Web Ontology Language access see https://en.wikipedia.org/wiki/Web_Ontology_Language</p> Source code in <code>skg/owl.py</code> <pre><code>class Owl(Schema):\n    \"\"\"\n    Web Ontology Language access\n    see https://en.wikipedia.org/wiki/Web_Ontology_Language\n    \"\"\"\n\n    def __init__(self, name: str, url: str, authors: str, inception: str):\n        \"\"\"\n        constructor\n\n        Args:\n            name(str): the name of this schema\n            url(str): the url of this schema\n            authors(str): the authors of this schema\n            inception(str): the inception of this schema\n        \"\"\"\n        Schema.__init__(self, name, url, authors, inception)\n        self.schema_url = url\n        self.schema = None\n\n    def show_triples(self, result):\n        \"\"\"\n        show the triples for the given query result\n        \"\"\"\n        for i, row in enumerate(result):\n            print(f\"{i+1}:{row}\")\n\n    def query_schema(self, query: str, formats: str = \"\", profile: bool = False):\n        \"\"\"\n        query the schema\n\n        Args:\n            query(str): the SPARQL query to execute\n            formats(str): if \"triples\" is in th format string show the results string\n            profile(bool): if True show timing information for the query\n        \"\"\"\n        profiler = Profiler(f\"query {query}\", profile=profile)\n        result = self.schema.query(query)\n        if \"triples\" in formats:\n            self.show_triples(result)\n        if profile:\n            profiler.time(f\" for {len(result)} triples\")\n        return result\n\n    def loadSchema(self, formats: str = \"\", profile: bool = False):\n        \"\"\"\n        load the schema\n\n        Args:\n            formats(str): the formats to dump\n            profile(bool): if True show timing\n        \"\"\"\n        # https://stackoverflow.com/questions/56631109/how-to-parse-and-load-an-ontology-in-python\n        profiler = Profiler(f\"reading {self.name} schema\", profile=profile)\n        self.schema = rdflib.Graph()\n        self.schema.parse(self.schema_url, format=\"application/rdf+xml\")\n        if profile:\n            profiler.time(f\" for {len(self.schema)} triples\")\n        for t_format in formats.split(\",\"):\n            if t_format and t_format != \"triples\":\n                print(self.schema.serialize(format=t_format))\n        self.schema.bind(\"owl\", OWL)\n        query = \"\"\"select distinct ?s ?p ?o \nwhere { ?s ?p ?o}\n\"\"\"\n        self.query_schema(query, formats=formats, profile=profile)\n        return self.schema\n\n    def unprefix_value(\n        self, value: object, prefixes: list = [\"http://xmlns.com/foaf/0.1/\"]\n    ) -&gt; str:\n        \"\"\"\n        get rid of RDF prefixes to simplify our life\n\n        Args:\n            value(object): the RDFLib value to unprefix\n            prefixes(list): list of prefixes to remove\n        Returns:\n            str: a simple string representation\n        \"\"\"\n        if isinstance(value, list):\n            if len(value) &gt;= 1:\n                value = value[0]\n        if isinstance(value, dict):\n            for akey in [\"@id\", \"@value\"]:\n                if akey in value:\n                    value = value[akey]\n        if isinstance(value, str):\n            parts = value.split(\"#\")\n            if len(parts) == 2:\n                value = parts[1]\n        for prefix in prefixes:\n            if value.startswith(prefix):\n                value = value.replace(prefix, \"\")\n        return value\n\n    def unprefix_row(self, row: dict):\n        \"\"\"\n        get rid of the RDF prefixes in keys and values of the given row\n        to simplify our life\n\n        Args:\n            row(dict): a dict of RDF values to unprefix\n        \"\"\"\n        for key in list(row.keys()):\n            org_value = row[key]\n            value = self.unprefix_value(org_value)\n            row[key] = value\n            if \"#\" in key:\n                noprefix_key = self.unprefix_value(key)\n                row[noprefix_key] = row.pop(key)\n            row[f\"{key}_rdf\"] = org_value\n\n    def toClasses(self):\n        \"\"\"\n        convert to a classes dict of dicts\n\n        Returns:\n            dict: a dict of dictionaries\n        \"\"\"\n        json_ld = self.schema.serialize(format=\"json-ld\")\n        schema_dict = json.loads(json_ld)\n        classes = {}\n        # get rid of prefixes\n        for row in schema_dict:\n            self.unprefix_row(row)\n        # pass 1 - classes\n        for row in schema_dict:\n            name = row[\"@id\"]\n            ptype = row[\"@type\"]\n            comment = row.get(\"comment\", \"\")\n            label = row.get(\"label\", \"\")\n            subClassOf = row.get(\"subClassOf\", \"\")\n            if ptype == \"Class\":\n                if name in classes:\n                    clazz = classes[name]\n                else:\n                    clazz = {\n                        \"@comment\": comment,\n                        \"@label\": label,\n                        \"@subClassOf\": subClassOf,\n                    }\n                    classes[name] = clazz\n        # pass 2 - properties\n        for row in schema_dict:\n            name = row[\"@id\"]\n            ptype = row[\"@type\"]\n            comment = row.get(\"comment\", \"\")\n            domain = row.get(\"domain\", \"\")\n            prange = row.get(\"range\", \"\")\n            plabel = row.get(\"label\")\n            if ptype == \"Property\":\n                prop = {\n                    \"name\": name,\n                    \"comment\": comment,\n                    \"label\": plabel,\n                    \"domain\": domain,\n                    \"range\": prange,\n                }\n                if domain in classes:\n                    clazz = classes[domain]\n                    clazz[name] = prop\n            pass\n        wrapped_classes = {\"classes\": classes}\n        return wrapped_classes\n</code></pre>"},{"location":"#skg.owl.Owl.__init__","title":"<code>__init__(name, url, authors, inception)</code>","text":"<p>constructor</p> <p>Parameters:</p> Name Type Description Default <code>name(str)</code> <p>the name of this schema</p> required <code>url(str)</code> <p>the url of this schema</p> required <code>authors(str)</code> <p>the authors of this schema</p> required <code>inception(str)</code> <p>the inception of this schema</p> required Source code in <code>skg/owl.py</code> <pre><code>def __init__(self, name: str, url: str, authors: str, inception: str):\n    \"\"\"\n    constructor\n\n    Args:\n        name(str): the name of this schema\n        url(str): the url of this schema\n        authors(str): the authors of this schema\n        inception(str): the inception of this schema\n    \"\"\"\n    Schema.__init__(self, name, url, authors, inception)\n    self.schema_url = url\n    self.schema = None\n</code></pre>"},{"location":"#skg.owl.Owl.loadSchema","title":"<code>loadSchema(formats='', profile=False)</code>","text":"<p>load the schema</p> <p>Parameters:</p> Name Type Description Default <code>formats(str)</code> <p>the formats to dump</p> required <code>profile(bool)</code> <p>if True show timing</p> required Source code in <code>skg/owl.py</code> <pre><code>    def loadSchema(self, formats: str = \"\", profile: bool = False):\n        \"\"\"\n        load the schema\n\n        Args:\n            formats(str): the formats to dump\n            profile(bool): if True show timing\n        \"\"\"\n        # https://stackoverflow.com/questions/56631109/how-to-parse-and-load-an-ontology-in-python\n        profiler = Profiler(f\"reading {self.name} schema\", profile=profile)\n        self.schema = rdflib.Graph()\n        self.schema.parse(self.schema_url, format=\"application/rdf+xml\")\n        if profile:\n            profiler.time(f\" for {len(self.schema)} triples\")\n        for t_format in formats.split(\",\"):\n            if t_format and t_format != \"triples\":\n                print(self.schema.serialize(format=t_format))\n        self.schema.bind(\"owl\", OWL)\n        query = \"\"\"select distinct ?s ?p ?o \nwhere { ?s ?p ?o}\n\"\"\"\n        self.query_schema(query, formats=formats, profile=profile)\n        return self.schema\n</code></pre>"},{"location":"#skg.owl.Owl.query_schema","title":"<code>query_schema(query, formats='', profile=False)</code>","text":"<p>query the schema</p> <p>Parameters:</p> Name Type Description Default <code>query(str)</code> <p>the SPARQL query to execute</p> required <code>formats(str)</code> <p>if \"triples\" is in th format string show the results string</p> required <code>profile(bool)</code> <p>if True show timing information for the query</p> required Source code in <code>skg/owl.py</code> <pre><code>def query_schema(self, query: str, formats: str = \"\", profile: bool = False):\n    \"\"\"\n    query the schema\n\n    Args:\n        query(str): the SPARQL query to execute\n        formats(str): if \"triples\" is in th format string show the results string\n        profile(bool): if True show timing information for the query\n    \"\"\"\n    profiler = Profiler(f\"query {query}\", profile=profile)\n    result = self.schema.query(query)\n    if \"triples\" in formats:\n        self.show_triples(result)\n    if profile:\n        profiler.time(f\" for {len(result)} triples\")\n    return result\n</code></pre>"},{"location":"#skg.owl.Owl.show_triples","title":"<code>show_triples(result)</code>","text":"<p>show the triples for the given query result</p> Source code in <code>skg/owl.py</code> <pre><code>def show_triples(self, result):\n    \"\"\"\n    show the triples for the given query result\n    \"\"\"\n    for i, row in enumerate(result):\n        print(f\"{i+1}:{row}\")\n</code></pre>"},{"location":"#skg.owl.Owl.toClasses","title":"<code>toClasses()</code>","text":"<p>convert to a classes dict of dicts</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>a dict of dictionaries</p> Source code in <code>skg/owl.py</code> <pre><code>def toClasses(self):\n    \"\"\"\n    convert to a classes dict of dicts\n\n    Returns:\n        dict: a dict of dictionaries\n    \"\"\"\n    json_ld = self.schema.serialize(format=\"json-ld\")\n    schema_dict = json.loads(json_ld)\n    classes = {}\n    # get rid of prefixes\n    for row in schema_dict:\n        self.unprefix_row(row)\n    # pass 1 - classes\n    for row in schema_dict:\n        name = row[\"@id\"]\n        ptype = row[\"@type\"]\n        comment = row.get(\"comment\", \"\")\n        label = row.get(\"label\", \"\")\n        subClassOf = row.get(\"subClassOf\", \"\")\n        if ptype == \"Class\":\n            if name in classes:\n                clazz = classes[name]\n            else:\n                clazz = {\n                    \"@comment\": comment,\n                    \"@label\": label,\n                    \"@subClassOf\": subClassOf,\n                }\n                classes[name] = clazz\n    # pass 2 - properties\n    for row in schema_dict:\n        name = row[\"@id\"]\n        ptype = row[\"@type\"]\n        comment = row.get(\"comment\", \"\")\n        domain = row.get(\"domain\", \"\")\n        prange = row.get(\"range\", \"\")\n        plabel = row.get(\"label\")\n        if ptype == \"Property\":\n            prop = {\n                \"name\": name,\n                \"comment\": comment,\n                \"label\": plabel,\n                \"domain\": domain,\n                \"range\": prange,\n            }\n            if domain in classes:\n                clazz = classes[domain]\n                clazz[name] = prop\n        pass\n    wrapped_classes = {\"classes\": classes}\n    return wrapped_classes\n</code></pre>"},{"location":"#skg.owl.Owl.unprefix_row","title":"<code>unprefix_row(row)</code>","text":"<p>get rid of the RDF prefixes in keys and values of the given row to simplify our life</p> <p>Parameters:</p> Name Type Description Default <code>row(dict)</code> <p>a dict of RDF values to unprefix</p> required Source code in <code>skg/owl.py</code> <pre><code>def unprefix_row(self, row: dict):\n    \"\"\"\n    get rid of the RDF prefixes in keys and values of the given row\n    to simplify our life\n\n    Args:\n        row(dict): a dict of RDF values to unprefix\n    \"\"\"\n    for key in list(row.keys()):\n        org_value = row[key]\n        value = self.unprefix_value(org_value)\n        row[key] = value\n        if \"#\" in key:\n            noprefix_key = self.unprefix_value(key)\n            row[noprefix_key] = row.pop(key)\n        row[f\"{key}_rdf\"] = org_value\n</code></pre>"},{"location":"#skg.owl.Owl.unprefix_value","title":"<code>unprefix_value(value, prefixes=['http://xmlns.com/foaf/0.1/'])</code>","text":"<p>get rid of RDF prefixes to simplify our life</p> <p>Parameters:</p> Name Type Description Default <code>value(object)</code> <p>the RDFLib value to unprefix</p> required <code>prefixes(list)</code> <p>list of prefixes to remove</p> required <p>Returns:     str: a simple string representation</p> Source code in <code>skg/owl.py</code> <pre><code>def unprefix_value(\n    self, value: object, prefixes: list = [\"http://xmlns.com/foaf/0.1/\"]\n) -&gt; str:\n    \"\"\"\n    get rid of RDF prefixes to simplify our life\n\n    Args:\n        value(object): the RDFLib value to unprefix\n        prefixes(list): list of prefixes to remove\n    Returns:\n        str: a simple string representation\n    \"\"\"\n    if isinstance(value, list):\n        if len(value) &gt;= 1:\n            value = value[0]\n    if isinstance(value, dict):\n        for akey in [\"@id\", \"@value\"]:\n            if akey in value:\n                value = value[akey]\n    if isinstance(value, str):\n        parts = value.split(\"#\")\n        if len(parts) == 2:\n            value = parts[1]\n    for prefix in prefixes:\n        if value.startswith(prefix):\n            value = value.replace(prefix, \"\")\n    return value\n</code></pre>"},{"location":"#skg.paper","title":"<code>paper</code>","text":"<p>Created on 2022-11-16</p> <p>@author: wf</p>"},{"location":"#skg.paper.Paper","title":"<code>Paper</code>","text":"<p>               Bases: <code>Node</code></p> <p>a scientific paper</p> Source code in <code>skg/paper.py</code> <pre><code>class Paper(skg.graph.Node):\n    \"\"\"\n    a scientific paper\n    \"\"\"\n\n    @classmethod\n    def getSamples(cls):\n        samples = [\n            {\n                \"wikiDataId\": \"Q55693406\",\n                \"title\": \"Designing the web for an open society\",\n                \"doi\": \"10.1145/1963405.1963408\",\n                \"DBLP_publication_ID\": \"conf/www/Berners-Lee11\",\n                \"publication_date\": 2011,\n            },\n            {\n                \"doi\": \"10.1007/978-3-031-19433-7_21\",\n                \"title\": \"An Analysis of\u00a0Content Gaps Versus User Needs in\u00a0the\u00a0Wikidata Knowledge Graph\",\n            },\n        ]\n        return samples\n\n    def __init__(self):\n        \"\"\"\n        Constructor\n        \"\"\"\n\n    def fromDOI(self, doi: str):\n        \"\"\"\n        construct me from the given doi\n        \"\"\"\n        self.doi = doi\n        self.doi_obj = DOI(doi)\n        self.doi_obj.meta_data = self.doi_obj.doi2Citeproc()\n        if not hasattr(self, \"title\"):\n            self.title = self.doi_obj.meta_data[\"title\"]\n        if not hasattr(self, \"label\"):\n            self.label = f\"https://doi.org/{self.doi}\"\n</code></pre>"},{"location":"#skg.paper.Paper.__init__","title":"<code>__init__()</code>","text":"<p>Constructor</p> Source code in <code>skg/paper.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Constructor\n    \"\"\"\n</code></pre>"},{"location":"#skg.paper.Paper.fromDOI","title":"<code>fromDOI(doi)</code>","text":"<p>construct me from the given doi</p> Source code in <code>skg/paper.py</code> <pre><code>def fromDOI(self, doi: str):\n    \"\"\"\n    construct me from the given doi\n    \"\"\"\n    self.doi = doi\n    self.doi_obj = DOI(doi)\n    self.doi_obj.meta_data = self.doi_obj.doi2Citeproc()\n    if not hasattr(self, \"title\"):\n        self.title = self.doi_obj.meta_data[\"title\"]\n    if not hasattr(self, \"label\"):\n        self.label = f\"https://doi.org/{self.doi}\"\n</code></pre>"},{"location":"#skg.profiler","title":"<code>profiler</code>","text":"<p>Created on 2022-11-18</p> <p>@author: wf</p>"},{"location":"#skg.profiler.Profiler","title":"<code>Profiler</code>","text":"<p>simple profiler</p> Source code in <code>skg/profiler.py</code> <pre><code>class Profiler:\n    \"\"\"\n    simple profiler\n    \"\"\"\n\n    def __init__(self, msg, profile=True):\n        \"\"\"\n        construct me with the given msg and profile active flag\n\n        Args:\n            msg(str): the message to show if profiling is active\n            profile(bool): True if messages should be shown\n        \"\"\"\n        self.msg = msg\n        self.profile = profile\n        self.starttime = time.time()\n        if profile:\n            print(f\"Starting {msg} ...\")\n\n    def time(self, extraMsg=\"\"):\n        \"\"\"\n        time the action and print if profile is active\n        \"\"\"\n        elapsed = time.time() - self.starttime\n        if self.profile:\n            print(f\"{self.msg}{extraMsg} took {elapsed:5.1f} s\")\n        return elapsed\n</code></pre>"},{"location":"#skg.profiler.Profiler.__init__","title":"<code>__init__(msg, profile=True)</code>","text":"<p>construct me with the given msg and profile active flag</p> <p>Parameters:</p> Name Type Description Default <code>msg(str)</code> <p>the message to show if profiling is active</p> required <code>profile(bool)</code> <p>True if messages should be shown</p> required Source code in <code>skg/profiler.py</code> <pre><code>def __init__(self, msg, profile=True):\n    \"\"\"\n    construct me with the given msg and profile active flag\n\n    Args:\n        msg(str): the message to show if profiling is active\n        profile(bool): True if messages should be shown\n    \"\"\"\n    self.msg = msg\n    self.profile = profile\n    self.starttime = time.time()\n    if profile:\n        print(f\"Starting {msg} ...\")\n</code></pre>"},{"location":"#skg.profiler.Profiler.time","title":"<code>time(extraMsg='')</code>","text":"<p>time the action and print if profile is active</p> Source code in <code>skg/profiler.py</code> <pre><code>def time(self, extraMsg=\"\"):\n    \"\"\"\n    time the action and print if profile is active\n    \"\"\"\n    elapsed = time.time() - self.starttime\n    if self.profile:\n        print(f\"{self.msg}{extraMsg} took {elapsed:5.1f} s\")\n    return elapsed\n</code></pre>"},{"location":"#skg.ris","title":"<code>ris</code>","text":"<p>Created on 2024-03-08</p> <p>@author: wf</p>"},{"location":"#skg.ris.RIS_Entry","title":"<code>RIS_Entry</code>","text":"<p>Research Information Systems format https://en.wikipedia.org/wiki/RIS_(file_format)</p> Source code in <code>skg/ris.py</code> <pre><code>@lod_storable\nclass RIS_Entry:\n    \"\"\"\n    Research Information Systems format\n    https://en.wikipedia.org/wiki/RIS_(file_format)\n    \"\"\"\n\n    type_of_reference: Optional[str] = None\n    abstract: Optional[str] = None\n    type_of_work: Optional[str] = None\n    year: Optional[str] = None\n    doi: Optional[str] = None\n    keywords: List[str] = field(default_factory=list)\n    first_authors: List[str] = field(default_factory=list)\n    publisher: Optional[str] = None\n    language: Optional[str] = None\n    primary_title: Optional[str] = None\n    urls: List[str] = field(default_factory=list)\n    secondary_title: Optional[str] = None\n\n    @property\n    def lang_qid(self) -&gt; str:\n        qid = \"Q1860\"  # English\n        if self.language == \"de\":\n            qid = \"Q188\"\n        return qid\n\n    @classmethod\n    def get_property_mappings(cls):\n        \"\"\"\n        get the wikidata property mappings\n        \"\"\"\n        mappings = [\n            PropertyMapping(\n                column=\"instanceof\",\n                propertyName=\"instanceof\",\n                propertyId=\"P31\",\n                propertyType=WdDatatype.itemid,\n                value=\"Q13442814\",  # scholarly article\n            ),\n            PropertyMapping(\n                column=\"primary_title\",\n                propertyName=\"title\",\n                propertyId=\"P1476\",\n                propertyType=WdDatatype.text,\n            ),\n            PropertyMapping(\n                column=\"doi\",\n                # propertyName=\"DOI\",\n                # propertyId=\"P356\",\n                propertyName=\"described at URL\",\n                propertyId=\"P973\",\n                # propertyType=WdDatatype.extid,\n                propertyType=WdDatatype.url,\n            ),\n            PropertyMapping(\n                column=\"lang_qid\",\n                propertyName=\"language of work or name\",\n                propertyId=\"P407\",\n                propertyType=WdDatatype.itemid,\n            ),\n            PropertyMapping(\n                column=\"year\",\n                propertyName=\"publication date\",\n                propertyId=\"P577\",\n                propertyType=WdDatatype.year,\n            ),\n        ]\n        return mappings\n\n    @classmethod\n    def get_dict_from_file(cls, ris_file_path, by_field: str = \"index\"):\n        ris_dict = {}\n        with open(ris_file_path, \"r\") as bibliography_file:\n            entries = rispy.load(bibliography_file)\n            for i, entry in enumerate(entries, start=1):\n                ris_entry = RIS_Entry.from_dict(entry)\n                if by_field == \"index\":\n                    value = i\n                else:\n                    if by_field in entry:\n                        value = field[entry]\n                ris_dict[value] = ris_entry\n\n        return ris_dict\n</code></pre>"},{"location":"#skg.ris.RIS_Entry.get_property_mappings","title":"<code>get_property_mappings()</code>  <code>classmethod</code>","text":"<p>get the wikidata property mappings</p> Source code in <code>skg/ris.py</code> <pre><code>@classmethod\ndef get_property_mappings(cls):\n    \"\"\"\n    get the wikidata property mappings\n    \"\"\"\n    mappings = [\n        PropertyMapping(\n            column=\"instanceof\",\n            propertyName=\"instanceof\",\n            propertyId=\"P31\",\n            propertyType=WdDatatype.itemid,\n            value=\"Q13442814\",  # scholarly article\n        ),\n        PropertyMapping(\n            column=\"primary_title\",\n            propertyName=\"title\",\n            propertyId=\"P1476\",\n            propertyType=WdDatatype.text,\n        ),\n        PropertyMapping(\n            column=\"doi\",\n            # propertyName=\"DOI\",\n            # propertyId=\"P356\",\n            propertyName=\"described at URL\",\n            propertyId=\"P973\",\n            # propertyType=WdDatatype.extid,\n            propertyType=WdDatatype.url,\n        ),\n        PropertyMapping(\n            column=\"lang_qid\",\n            propertyName=\"language of work or name\",\n            propertyId=\"P407\",\n            propertyType=WdDatatype.itemid,\n        ),\n        PropertyMapping(\n            column=\"year\",\n            propertyName=\"publication date\",\n            propertyId=\"P577\",\n            propertyType=WdDatatype.year,\n        ),\n    ]\n    return mappings\n</code></pre>"},{"location":"#skg.schema","title":"<code>schema</code>","text":"<p>Created on 2022-11-22</p> <p>@author: wf</p>"},{"location":"#skg.schema.Schema","title":"<code>Schema</code>","text":"<p>a schema</p> Source code in <code>skg/schema.py</code> <pre><code>class Schema:\n    \"\"\"\n    a schema\n    \"\"\"\n\n    def __init__(self, name: str, url: str, authors: str, inception: str):\n        \"\"\"\n        constructor\n\n        Args:\n            name(str): the name of this schema\n            url(str): the url of this schema\n            authors(str): the authors of this schema\n            inception(str): the inception of this schema\n        \"\"\"\n        self.name = name\n        self.url = url\n        self.authors = authors\n        self.inception = inception\n\n    def classesToPlantUml(self, classes: dict, indent: str = \"  \"):\n        \"\"\"\n        convert the given classes dict to plantuml\n\n        Args:\n            classes(dict): a dictionary of classes\n            indent(str): the indentation to apply\n        \"\"\"\n        classes = classes[\"classes\"]\n        markup = \"\"\n        for cname, clazz in classes.items():\n            class_markup = \"\"\n            rel_markup = \"\"  # relations\n            for pname, prop in clazz.items():\n                if pname.startswith(\"@\"):\n                    pass\n                else:\n                    prange = prop[\"range\"]\n                    if prange in classes:\n                        #  Class01 \"1\" *-- \"many\" Class02 : contains\n                        rel_markup += f\"{indent}{cname}--{prange}:{pname}\\n\"\n                    else:\n                        class_markup += f\"{indent}  {pname}:{prange}\\n\"\n            class_markup = f\"{indent}class {cname}{{\\n{class_markup}\\n{indent}}}\\n\"\n            class_markup += rel_markup\n            if \"@subClassOf\" in clazz:\n                general = clazz[\"@subClassOf\"]\n                if general:\n                    class_markup += f\"{indent}{general} &lt;|-- {cname}\\n\"\n            note = f\"{indent}note top of {cname}\\n\"\n            if \"@label\" in clazz:\n                note += f\"\"\"{indent}{clazz[\"@label\"]}\\n\"\"\"\n            if \"@comment\" in clazz:\n                note += f\"\"\"{indent}{clazz[\"@comment\"]}\\n\"\"\"\n            note += f\"{indent}end note\\n\"\n            class_markup = note + class_markup\n            markup += class_markup\n        return markup\n\n    def toPlantUml(self, header=None, footer=None) -&gt; str:\n        \"\"\"\n        get a plantuml version of the schema\n\n        Args:\n            header(str): the header to apply\n            footer(str): the footer to apply\n\n        Returns:\n            str: the plantuml markup\n        \"\"\"\n        timestamp = datetime.datetime.utcnow().strftime(\"%Y-%m-%d\")\n        if header is None:\n            header = f\"\"\"/'\n     {self.authors} {self.inception}\n     updated {timestamp}\n\n     {self.name} {self.schema_url}\n     converted from owl to plantuml\n    '/\n    title  {self.name} schema {self.schema_url} converted from owl to plantuml updated {timestamp}\n    hide circle\n    package foaf {{\n      class Document {{\n      }}\n    }}\n    package dblp {{\n     \"\"\"\n        if footer is None:\n            footer = \"}\\n\"\n        classes = self.toClasses()\n        markup = header + self.classesToPlantUml(classes, indent=\"  \") + footer\n        return markup\n</code></pre>"},{"location":"#skg.schema.Schema.__init__","title":"<code>__init__(name, url, authors, inception)</code>","text":"<p>constructor</p> <p>Parameters:</p> Name Type Description Default <code>name(str)</code> <p>the name of this schema</p> required <code>url(str)</code> <p>the url of this schema</p> required <code>authors(str)</code> <p>the authors of this schema</p> required <code>inception(str)</code> <p>the inception of this schema</p> required Source code in <code>skg/schema.py</code> <pre><code>def __init__(self, name: str, url: str, authors: str, inception: str):\n    \"\"\"\n    constructor\n\n    Args:\n        name(str): the name of this schema\n        url(str): the url of this schema\n        authors(str): the authors of this schema\n        inception(str): the inception of this schema\n    \"\"\"\n    self.name = name\n    self.url = url\n    self.authors = authors\n    self.inception = inception\n</code></pre>"},{"location":"#skg.schema.Schema.classesToPlantUml","title":"<code>classesToPlantUml(classes, indent='  ')</code>","text":"<p>convert the given classes dict to plantuml</p> <p>Parameters:</p> Name Type Description Default <code>classes(dict)</code> <p>a dictionary of classes</p> required <code>indent(str)</code> <p>the indentation to apply</p> required Source code in <code>skg/schema.py</code> <pre><code>def classesToPlantUml(self, classes: dict, indent: str = \"  \"):\n    \"\"\"\n    convert the given classes dict to plantuml\n\n    Args:\n        classes(dict): a dictionary of classes\n        indent(str): the indentation to apply\n    \"\"\"\n    classes = classes[\"classes\"]\n    markup = \"\"\n    for cname, clazz in classes.items():\n        class_markup = \"\"\n        rel_markup = \"\"  # relations\n        for pname, prop in clazz.items():\n            if pname.startswith(\"@\"):\n                pass\n            else:\n                prange = prop[\"range\"]\n                if prange in classes:\n                    #  Class01 \"1\" *-- \"many\" Class02 : contains\n                    rel_markup += f\"{indent}{cname}--{prange}:{pname}\\n\"\n                else:\n                    class_markup += f\"{indent}  {pname}:{prange}\\n\"\n        class_markup = f\"{indent}class {cname}{{\\n{class_markup}\\n{indent}}}\\n\"\n        class_markup += rel_markup\n        if \"@subClassOf\" in clazz:\n            general = clazz[\"@subClassOf\"]\n            if general:\n                class_markup += f\"{indent}{general} &lt;|-- {cname}\\n\"\n        note = f\"{indent}note top of {cname}\\n\"\n        if \"@label\" in clazz:\n            note += f\"\"\"{indent}{clazz[\"@label\"]}\\n\"\"\"\n        if \"@comment\" in clazz:\n            note += f\"\"\"{indent}{clazz[\"@comment\"]}\\n\"\"\"\n        note += f\"{indent}end note\\n\"\n        class_markup = note + class_markup\n        markup += class_markup\n    return markup\n</code></pre>"},{"location":"#skg.schema.Schema.toPlantUml","title":"<code>toPlantUml(header=None, footer=None)</code>","text":"<p>get a plantuml version of the schema</p> <p>Parameters:</p> Name Type Description Default <code>header(str)</code> <p>the header to apply</p> required <code>footer(str)</code> <p>the footer to apply</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the plantuml markup</p> Source code in <code>skg/schema.py</code> <pre><code>def toPlantUml(self, header=None, footer=None) -&gt; str:\n    \"\"\"\n    get a plantuml version of the schema\n\n    Args:\n        header(str): the header to apply\n        footer(str): the footer to apply\n\n    Returns:\n        str: the plantuml markup\n    \"\"\"\n    timestamp = datetime.datetime.utcnow().strftime(\"%Y-%m-%d\")\n    if header is None:\n        header = f\"\"\"/'\n {self.authors} {self.inception}\n updated {timestamp}\n\n {self.name} {self.schema_url}\n converted from owl to plantuml\n'/\ntitle  {self.name} schema {self.schema_url} converted from owl to plantuml updated {timestamp}\nhide circle\npackage foaf {{\n  class Document {{\n  }}\n}}\npackage dblp {{\n \"\"\"\n    if footer is None:\n        footer = \"}\\n\"\n    classes = self.toClasses()\n    markup = header + self.classesToPlantUml(classes, indent=\"  \") + footer\n    return markup\n</code></pre>"},{"location":"#skg.scholar","title":"<code>scholar</code>","text":"<p>Created on 2022-11-16</p> <p>@author: wf</p>"},{"location":"#skg.scholar.Institution","title":"<code>Institution</code>","text":"<p>               Bases: <code>Node</code></p> <p>academic institution a scholar might be affiliated with</p> Source code in <code>skg/scholar.py</code> <pre><code>class Institution(skg.graph.Node):\n    \"\"\"\n    academic institution a scholar might be affiliated with\n    \"\"\"\n\n    @classmethod\n    def getSamples(cls):\n        samples = [\n            {\"wikiDataId\": \"Q273263\", \"short_name\": \"RWTH Aachen (German)\"},\n            {\n                \"wikiDataId\": \"Q391028\",\n                \"inception\": \"1908\",\n                \"short_name\": \"UBC\",\n                \"country\": \"Canada\",\n                \"image\": \"https://commons.wikimedia.org/wiki/File:Irving_K._Barber_Library.jpg\",\n                \"located_in\": \"Vancouver\",\n                \"official_website\": \"https://www.ubc.ca/\",\n            },\n        ]\n        return samples\n\n    def __init__(self):\n        \"\"\"\n        constructor\n        \"\"\"\n</code></pre>"},{"location":"#skg.scholar.Institution.__init__","title":"<code>__init__()</code>","text":"<p>constructor</p> Source code in <code>skg/scholar.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    constructor\n    \"\"\"\n</code></pre>"},{"location":"#skg.scholar.Scholar","title":"<code>Scholar</code>","text":"<p>               Bases: <code>Node</code></p> <p>an instance of a scholar that writes papers to be an author</p> Source code in <code>skg/scholar.py</code> <pre><code>class Scholar(skg.graph.Node):\n    \"\"\"\n    an instance of a scholar that writes papers to be an author\n    \"\"\"\n\n    @classmethod\n    def getSamples(cls):\n        samples = [\n            {\n                \"wikiDataId\": \"Q54303353\",\n                \"name\": \"Stefan Decker\",\n                \"gndId\": \"\",\n                \"dblpId\": \"d/StefanDecker\",\n                \"orcid\": \"0000-0001-6324-7164\",\n                \"linkedInId\": \"\",\n                \"googleScholarUser\": \"uhVkSswAAAAJ\",\n                \"homepage\": \"http://www.stefandecker.org\",\n            },\n            {\n                \"name\": \"Tim Berners-Lee\",\n                \"wikiDataId\": \"Q80\",\n                \"givenName\": \"Timothy\",\n                \"familyName\": \"Berners-Lee\",\n                \"gender\": \"male\",\n                \"image\": \"https://commons.wikimedia.org/wiki/File:Sir_Tim_Berners-Lee_(cropped).jpg\",\n                # \"occupation\": \"computer scientist\" truly tabular issue\n            },\n            {\n                \"name\": \"Anna Lisa Gentile\",\n                \"wikiDataId\": \"Q54832532\",\n                \"Semantic_Scholar_author_ID\": \"Anna Lisa Gentile\",\n            },\n        ]\n        return samples\n\n    def __init__(self):\n        \"\"\"\n        constructor\n        \"\"\"\n</code></pre>"},{"location":"#skg.scholar.Scholar.__init__","title":"<code>__init__()</code>","text":"<p>constructor</p> Source code in <code>skg/scholar.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    constructor\n    \"\"\"\n</code></pre>"},{"location":"#skg.scholargrid","title":"<code>scholargrid</code>","text":"<p>Created on 2023-01-04</p> <p>@author: wf</p>"},{"location":"#skg.scholargrid.ScholarGrid","title":"<code>ScholarGrid</code>","text":"<p>               Bases: <code>SmwGrid</code></p> <p>show a grid of scholars</p> Source code in <code>skg/scholargrid.py</code> <pre><code>class ScholarGrid(SmwGrid):\n    \"\"\"\n    show a grid of scholars\n    \"\"\"\n\n    def __init__(\n        self, app, wikiUsers, wikiId: str, sparql: SPARQL, debug: bool = False\n    ):\n        \"\"\"\n        constructor\n\n        Args:\n            app(App): the app that I am part of\n            wikiUsers(list): the wikiUsers\n            wikiId(str): the wikiId to use\n            sparql(SPARQL): the SPARQL endpoint to use\n            debug(bool): if True show debugging information\n        \"\"\"\n        entityName = \"Scholar\"\n        entityPluralName = \"Scholars\"\n        pk = \"item\"\n        super().__init__(\n            app=app,\n            wikiUsers=wikiUsers,\n            wikiId=wikiId,\n            entityName=entityName,\n            entityPluralName=entityPluralName,\n            pk=pk,\n            getLod=self.getScholars,\n            sparql=sparql,\n            debug=debug,\n        )\n\n    def getScholars(self) -&gt; list:\n        \"\"\"\n        get the list of scholars\n\n        Returns:\n            list: the list of dicts of scholars\n        \"\"\"\n        # get a dict of dict\n        scholars_dod = self.semwiki.scholars()\n        # get a list of dicts\n        scholars_lod = list(scholars_dod.values())\n        # @TODO - shouldn't this be better specified in the mapping?\n        for row in scholars_lod:\n            row[\"label\"] = row[\"Scholar\"]\n        self.wbQuery = ScholarQuery.get()\n        return scholars_lod\n</code></pre>"},{"location":"#skg.scholargrid.ScholarGrid.__init__","title":"<code>__init__(app, wikiUsers, wikiId, sparql, debug=False)</code>","text":"<p>constructor</p> <p>Parameters:</p> Name Type Description Default <code>app(App)</code> <p>the app that I am part of</p> required <code>wikiUsers(list)</code> <p>the wikiUsers</p> required <code>wikiId(str)</code> <p>the wikiId to use</p> required <code>sparql(SPARQL)</code> <p>the SPARQL endpoint to use</p> required <code>debug(bool)</code> <p>if True show debugging information</p> required Source code in <code>skg/scholargrid.py</code> <pre><code>def __init__(\n    self, app, wikiUsers, wikiId: str, sparql: SPARQL, debug: bool = False\n):\n    \"\"\"\n    constructor\n\n    Args:\n        app(App): the app that I am part of\n        wikiUsers(list): the wikiUsers\n        wikiId(str): the wikiId to use\n        sparql(SPARQL): the SPARQL endpoint to use\n        debug(bool): if True show debugging information\n    \"\"\"\n    entityName = \"Scholar\"\n    entityPluralName = \"Scholars\"\n    pk = \"item\"\n    super().__init__(\n        app=app,\n        wikiUsers=wikiUsers,\n        wikiId=wikiId,\n        entityName=entityName,\n        entityPluralName=entityPluralName,\n        pk=pk,\n        getLod=self.getScholars,\n        sparql=sparql,\n        debug=debug,\n    )\n</code></pre>"},{"location":"#skg.scholargrid.ScholarGrid.getScholars","title":"<code>getScholars()</code>","text":"<p>get the list of scholars</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>the list of dicts of scholars</p> Source code in <code>skg/scholargrid.py</code> <pre><code>def getScholars(self) -&gt; list:\n    \"\"\"\n    get the list of scholars\n\n    Returns:\n        list: the list of dicts of scholars\n    \"\"\"\n    # get a dict of dict\n    scholars_dod = self.semwiki.scholars()\n    # get a list of dicts\n    scholars_lod = list(scholars_dod.values())\n    # @TODO - shouldn't this be better specified in the mapping?\n    for row in scholars_lod:\n        row[\"label\"] = row[\"Scholar\"]\n    self.wbQuery = ScholarQuery.get()\n    return scholars_lod\n</code></pre>"},{"location":"#skg.scholargrid.ScholarQuery","title":"<code>ScholarQuery</code>","text":"Source code in <code>skg/scholargrid.py</code> <pre><code>class ScholarQuery:\n    @classmethod\n    def get(cls) -&gt; WikibaseQuery:\n        \"\"\"\n        get the WikiBaseQuery for scholars\n\n        Returns:\n            WikibaseQuery: the wikibase query\n        \"\"\"\n        scholar_mapping = [\n            # @TODO use metamodel info and read from wiki\n            {\n                \"Column\": \"\",\n                \"Entity\": \"Scholar\",\n                \"Lookup\": \"\",\n                \"PropVarname\": \"instanceof\",\n                \"PropertyId\": \"P31\",\n                \"PropertyName\": \"instanceof\",\n                \"Qualifier\": \"\",\n                \"Type\": \"\",\n                \"Value\": \"Q5\",\n            },\n            {\n                \"Column\": \"wikiDataId\",\n                \"Entity\": \"Scholar\",\n                \"Lookup\": \"\",\n                \"PropVarname\": \"\",\n                \"PropertyId\": \"\",\n                \"PropertyName\": \"\",\n                \"Qualifier\": \"\",\n                \"Type\": \"item\",\n                \"Value\": \"\",\n            },\n            {\n                \"Column\": \"name\",\n                \"Entity\": \"Scholar\",\n                \"Lookup\": \"Q101352\",\n                \"PropVarname\": \"family_name\",\n                \"PropertyId\": \"P734\",\n                \"PropertyName\": \"family name\",\n                \"Qualifier\": \"\",\n                \"Type\": \"\",\n                \"Value\": \"\",\n            },\n            {\n                \"Column\": \"firstName\",\n                \"Entity\": \"Scholar\",\n                \"Lookup\": \"Q202444\",\n                \"PropVarname\": \"given_name\",\n                \"PropertyId\": \"P735\",\n                \"PropertyName\": \"given name\",\n                \"Qualifier\": \"\",\n                \"Type\": \"\",\n                \"Value\": \"\",\n            },\n            {\n                \"Column\": \"homepage\",\n                \"Entity\": \"Scholar\",\n                \"Lookup\": \"\",\n                \"PropVarname\": \"official_website\",\n                \"PropertyId\": \"P856\",\n                \"PropertyName\": \"official website\",\n                \"Qualifier\": \"\",\n                \"Type\": \"url\",\n                \"Value\": \"\",\n            },\n            {\n                \"Column\": \"linkedInId\",\n                \"Entity\": \"Scholar\",\n                \"Lookup\": \"\",\n                \"PropVarname\": \"LinkedIn_personal_profile_ID\",\n                \"PropertyId\": \"P6634\",\n                \"PropertyName\": \"LinkedIn personal profile ID\",\n                \"Qualifier\": \"\",\n                \"Type\": \"extid\",\n                \"Value\": \"\",\n            },\n            {\n                \"Column\": \"orcid\",\n                \"Entity\": \"Scholar\",\n                \"Lookup\": \"\",\n                \"PropVarname\": \"ORCID_iD\",\n                \"PropertyId\": \"P496\",\n                \"PropertyName\": \"ORCID iD\",\n                \"Qualifier\": \"\",\n                \"Type\": \"extid\",\n                \"Value\": \"\",\n            },\n            {\n                \"Column\": \"googleScholarUser\",\n                \"Entity\": \"Scholar\",\n                \"Lookup\": \"\",\n                \"PropVarname\": \"Google_Scholar_author_ID\",\n                \"PropertyId\": \"P1960\",\n                \"PropertyName\": \"Google Scholar author ID\",\n                \"Qualifier\": \"\",\n                \"Type\": \"extid\",\n                \"Value\": \"\",\n            },\n            {\n                \"Column\": \"researchGate\",\n                \"Entity\": \"Scholar\",\n                \"Lookup\": \"\",\n                \"PropVarname\": \"ResearchGate_profile_ID\",\n                \"PropertyId\": \"P2038\",\n                \"PropertyName\": \"ResearchGate profile ID\",\n                \"Qualifier\": \"\",\n                \"Type\": \"extid\",\n                \"Value\": \"\",\n            },\n            {\n                \"Column\": \"gndId\",\n                \"Entity\": \"Scholar\",\n                \"Lookup\": \"\",\n                \"PropVarname\": \"GND_ID\",\n                \"PropertyId\": \"P227\",\n                \"PropertyName\": \"GND ID\",\n                \"Qualifier\": \"\",\n                \"Type\": \"extid\",\n                \"Value\": \"\",\n            },\n            {\n                \"Column\": \"dblpId\",\n                \"Entity\": \"Scholar\",\n                \"Lookup\": \"\",\n                \"PropVarname\": \"DBLP_author_ID\",\n                \"PropertyId\": \"P2456\",\n                \"PropertyName\": \"DBLP author ID\",\n                \"Qualifier\": \"\",\n                \"Type\": \"extid\",\n                \"Value\": \"\",\n            },\n        ]\n        wbQuery = WikibaseQuery(\"scholar\")\n        for row in scholar_mapping:\n            wbQuery.addPropertyFromDescriptionRow(row)\n        return wbQuery\n</code></pre>"},{"location":"#skg.scholargrid.ScholarQuery.get","title":"<code>get()</code>  <code>classmethod</code>","text":"<p>get the WikiBaseQuery for scholars</p> <p>Returns:</p> Name Type Description <code>WikibaseQuery</code> <code>WikibaseQuery</code> <p>the wikibase query</p> Source code in <code>skg/scholargrid.py</code> <pre><code>@classmethod\ndef get(cls) -&gt; WikibaseQuery:\n    \"\"\"\n    get the WikiBaseQuery for scholars\n\n    Returns:\n        WikibaseQuery: the wikibase query\n    \"\"\"\n    scholar_mapping = [\n        # @TODO use metamodel info and read from wiki\n        {\n            \"Column\": \"\",\n            \"Entity\": \"Scholar\",\n            \"Lookup\": \"\",\n            \"PropVarname\": \"instanceof\",\n            \"PropertyId\": \"P31\",\n            \"PropertyName\": \"instanceof\",\n            \"Qualifier\": \"\",\n            \"Type\": \"\",\n            \"Value\": \"Q5\",\n        },\n        {\n            \"Column\": \"wikiDataId\",\n            \"Entity\": \"Scholar\",\n            \"Lookup\": \"\",\n            \"PropVarname\": \"\",\n            \"PropertyId\": \"\",\n            \"PropertyName\": \"\",\n            \"Qualifier\": \"\",\n            \"Type\": \"item\",\n            \"Value\": \"\",\n        },\n        {\n            \"Column\": \"name\",\n            \"Entity\": \"Scholar\",\n            \"Lookup\": \"Q101352\",\n            \"PropVarname\": \"family_name\",\n            \"PropertyId\": \"P734\",\n            \"PropertyName\": \"family name\",\n            \"Qualifier\": \"\",\n            \"Type\": \"\",\n            \"Value\": \"\",\n        },\n        {\n            \"Column\": \"firstName\",\n            \"Entity\": \"Scholar\",\n            \"Lookup\": \"Q202444\",\n            \"PropVarname\": \"given_name\",\n            \"PropertyId\": \"P735\",\n            \"PropertyName\": \"given name\",\n            \"Qualifier\": \"\",\n            \"Type\": \"\",\n            \"Value\": \"\",\n        },\n        {\n            \"Column\": \"homepage\",\n            \"Entity\": \"Scholar\",\n            \"Lookup\": \"\",\n            \"PropVarname\": \"official_website\",\n            \"PropertyId\": \"P856\",\n            \"PropertyName\": \"official website\",\n            \"Qualifier\": \"\",\n            \"Type\": \"url\",\n            \"Value\": \"\",\n        },\n        {\n            \"Column\": \"linkedInId\",\n            \"Entity\": \"Scholar\",\n            \"Lookup\": \"\",\n            \"PropVarname\": \"LinkedIn_personal_profile_ID\",\n            \"PropertyId\": \"P6634\",\n            \"PropertyName\": \"LinkedIn personal profile ID\",\n            \"Qualifier\": \"\",\n            \"Type\": \"extid\",\n            \"Value\": \"\",\n        },\n        {\n            \"Column\": \"orcid\",\n            \"Entity\": \"Scholar\",\n            \"Lookup\": \"\",\n            \"PropVarname\": \"ORCID_iD\",\n            \"PropertyId\": \"P496\",\n            \"PropertyName\": \"ORCID iD\",\n            \"Qualifier\": \"\",\n            \"Type\": \"extid\",\n            \"Value\": \"\",\n        },\n        {\n            \"Column\": \"googleScholarUser\",\n            \"Entity\": \"Scholar\",\n            \"Lookup\": \"\",\n            \"PropVarname\": \"Google_Scholar_author_ID\",\n            \"PropertyId\": \"P1960\",\n            \"PropertyName\": \"Google Scholar author ID\",\n            \"Qualifier\": \"\",\n            \"Type\": \"extid\",\n            \"Value\": \"\",\n        },\n        {\n            \"Column\": \"researchGate\",\n            \"Entity\": \"Scholar\",\n            \"Lookup\": \"\",\n            \"PropVarname\": \"ResearchGate_profile_ID\",\n            \"PropertyId\": \"P2038\",\n            \"PropertyName\": \"ResearchGate profile ID\",\n            \"Qualifier\": \"\",\n            \"Type\": \"extid\",\n            \"Value\": \"\",\n        },\n        {\n            \"Column\": \"gndId\",\n            \"Entity\": \"Scholar\",\n            \"Lookup\": \"\",\n            \"PropVarname\": \"GND_ID\",\n            \"PropertyId\": \"P227\",\n            \"PropertyName\": \"GND ID\",\n            \"Qualifier\": \"\",\n            \"Type\": \"extid\",\n            \"Value\": \"\",\n        },\n        {\n            \"Column\": \"dblpId\",\n            \"Entity\": \"Scholar\",\n            \"Lookup\": \"\",\n            \"PropVarname\": \"DBLP_author_ID\",\n            \"PropertyId\": \"P2456\",\n            \"PropertyName\": \"DBLP author ID\",\n            \"Qualifier\": \"\",\n            \"Type\": \"extid\",\n            \"Value\": \"\",\n        },\n    ]\n    wbQuery = WikibaseQuery(\"scholar\")\n    for row in scholar_mapping:\n        wbQuery.addPropertyFromDescriptionRow(row)\n    return wbQuery\n</code></pre>"},{"location":"#skg.scholargrid.SmwGrid","title":"<code>SmwGrid</code>","text":"<p>               Bases: <code>GridSync</code></p> <p>a semantic mediawiki based grid synchable with WikiData</p> Source code in <code>skg/scholargrid.py</code> <pre><code>class SmwGrid(GridSync):\n    \"\"\"\n    a semantic mediawiki based grid synchable with WikiData\n\n    \"\"\"\n\n    def __init__(\n        self,\n        solution,\n        entityName: str,\n        entityPluralName: str,\n        pk: str,\n        getLod: Callable,\n        wikiUsers: list,\n        wikiId: str,\n        sparql: SPARQL,\n        debug: bool = False,\n    ):\n        \"\"\"\n        constructor\n\n        Args:\n            solution:  the solutio that i am part of\n            entityName(str): the name of the entity type of items to be shown in the grid\n            entityPluralName(str): the plural name of the entities to be shown\n            pk(str): the name of the primary key\n            getLod(Callable): the callback to load the grid rows list of dicts\n            wikiUsers(list): the wikiUsers\n            wikiId(str): the wikiId to use\n            sparql(SPARQL): the SPARQL endpoint to use\n            debug(bool): if True show debugging information\n        \"\"\"\n        self.solution = solution\n        self.wikiUsers = wikiUsers\n        self.wikiId = wikiId\n        wikiUser = self.wikiUsers[wikiId]\n        self.semwiki = SemWiki(wikiUser)\n        wdGrid = WikidataGrid(\n            app=app,\n            source=wikiId,\n            entityName=entityName,\n            entityPluralName=entityPluralName,\n            getLod=getLod,\n            debug=debug,\n        )\n        # we'd rather lazy load\n        # wdGrid.lod=wdGrid.getLod()\n        super().__init__(wdGrid, entityName, pk, sparql=sparql, debug=debug)\n</code></pre>"},{"location":"#skg.scholargrid.SmwGrid.__init__","title":"<code>__init__(solution, entityName, entityPluralName, pk, getLod, wikiUsers, wikiId, sparql, debug=False)</code>","text":"<p>constructor</p> <p>Parameters:</p> Name Type Description Default <code>solution</code> <p>the solutio that i am part of</p> required <code>entityName(str)</code> <p>the name of the entity type of items to be shown in the grid</p> required <code>entityPluralName(str)</code> <p>the plural name of the entities to be shown</p> required <code>pk(str)</code> <p>the name of the primary key</p> required <code>getLod(Callable)</code> <p>the callback to load the grid rows list of dicts</p> required <code>wikiUsers(list)</code> <p>the wikiUsers</p> required <code>wikiId(str)</code> <p>the wikiId to use</p> required <code>sparql(SPARQL)</code> <p>the SPARQL endpoint to use</p> required <code>debug(bool)</code> <p>if True show debugging information</p> required Source code in <code>skg/scholargrid.py</code> <pre><code>def __init__(\n    self,\n    solution,\n    entityName: str,\n    entityPluralName: str,\n    pk: str,\n    getLod: Callable,\n    wikiUsers: list,\n    wikiId: str,\n    sparql: SPARQL,\n    debug: bool = False,\n):\n    \"\"\"\n    constructor\n\n    Args:\n        solution:  the solutio that i am part of\n        entityName(str): the name of the entity type of items to be shown in the grid\n        entityPluralName(str): the plural name of the entities to be shown\n        pk(str): the name of the primary key\n        getLod(Callable): the callback to load the grid rows list of dicts\n        wikiUsers(list): the wikiUsers\n        wikiId(str): the wikiId to use\n        sparql(SPARQL): the SPARQL endpoint to use\n        debug(bool): if True show debugging information\n    \"\"\"\n    self.solution = solution\n    self.wikiUsers = wikiUsers\n    self.wikiId = wikiId\n    wikiUser = self.wikiUsers[wikiId]\n    self.semwiki = SemWiki(wikiUser)\n    wdGrid = WikidataGrid(\n        app=app,\n        source=wikiId,\n        entityName=entityName,\n        entityPluralName=entityPluralName,\n        getLod=getLod,\n        debug=debug,\n    )\n    # we'd rather lazy load\n    # wdGrid.lod=wdGrid.getLod()\n    super().__init__(wdGrid, entityName, pk, sparql=sparql, debug=debug)\n</code></pre>"},{"location":"#skg.search","title":"<code>search</code>","text":"<p>Created on 2022-11-19</p> <p>@author: wf</p>"},{"location":"#skg.search.SearchOptions","title":"<code>SearchOptions</code>","text":"<p>wrapper for search results</p> Source code in <code>skg/search.py</code> <pre><code>class SearchOptions:\n    \"\"\"\n    wrapper for search results\n    \"\"\"\n\n    def __init__(\n        self,\n        limit: int = 9,\n        lang=\"en\",\n        show: bool = True,\n        markup_names=[\"bibtex\"],\n        open_browser: bool = False,\n    ):\n        \"\"\"\n        constructor\n\n        Args:\n            limit(int): limit for the maximum number of results\n            lang(str): the language code to use for the search\n            show(bool): if True print the search results\n            markup_names(list): a list of markup names to support\n            open_browser(bool): if True open a browser for the target page of the item e.g. scholia\n\n        \"\"\"\n        self.limit = limit\n        self.lang = lang\n        self.show = show\n        self.markup_names = markup_names\n        self.open_browser = open_browser\n</code></pre>"},{"location":"#skg.search.SearchOptions.__init__","title":"<code>__init__(limit=9, lang='en', show=True, markup_names=['bibtex'], open_browser=False)</code>","text":"<p>constructor</p> <p>Parameters:</p> Name Type Description Default <code>limit(int)</code> <p>limit for the maximum number of results</p> required <code>lang(str)</code> <p>the language code to use for the search</p> required <code>show(bool)</code> <p>if True print the search results</p> required <code>markup_names(list)</code> <p>a list of markup names to support</p> required <code>open_browser(bool)</code> <p>if True open a browser for the target page of the item e.g. scholia</p> required Source code in <code>skg/search.py</code> <pre><code>def __init__(\n    self,\n    limit: int = 9,\n    lang=\"en\",\n    show: bool = True,\n    markup_names=[\"bibtex\"],\n    open_browser: bool = False,\n):\n    \"\"\"\n    constructor\n\n    Args:\n        limit(int): limit for the maximum number of results\n        lang(str): the language code to use for the search\n        show(bool): if True print the search results\n        markup_names(list): a list of markup names to support\n        open_browser(bool): if True open a browser for the target page of the item e.g. scholia\n\n    \"\"\"\n    self.limit = limit\n    self.lang = lang\n    self.show = show\n    self.markup_names = markup_names\n    self.open_browser = open_browser\n</code></pre>"},{"location":"#skg.search.SearchResult","title":"<code>SearchResult</code>","text":"<p>wrapper for search results</p> Source code in <code>skg/search.py</code> <pre><code>class SearchResult:\n    \"\"\"\n    wrapper for search results\n    \"\"\"\n\n    def __init__(self, search_list: list, options=SearchOptions):\n        \"\"\"\n        constructor\n\n         Args:\n            search_list(list): a list of search terms\n            options(SearchOptions): the search options to apply\n        \"\"\"\n        self.search_list = search_list\n        self.options = options\n        self.items = []\n</code></pre>"},{"location":"#skg.search.SearchResult.__init__","title":"<code>__init__(search_list, options=SearchOptions)</code>","text":"<p>constructor</p> <p>Args:     search_list(list): a list of search terms     options(SearchOptions): the search options to apply</p> Source code in <code>skg/search.py</code> <pre><code>def __init__(self, search_list: list, options=SearchOptions):\n    \"\"\"\n    constructor\n\n     Args:\n        search_list(list): a list of search terms\n        options(SearchOptions): the search options to apply\n    \"\"\"\n    self.search_list = search_list\n    self.options = options\n    self.items = []\n</code></pre>"},{"location":"#skg.searchengine","title":"<code>searchengine</code>","text":"<p>Created on 18.11.2022</p> <p>@author: wf</p>"},{"location":"#skg.searchengine.InternetSearch","title":"<code>InternetSearch</code>","text":"<p>generic internet search</p> Source code in <code>skg/searchengine.py</code> <pre><code>class InternetSearch:\n    \"\"\"\n    generic internet search\n    \"\"\"\n\n    def __init__(self, debug: bool = False):\n        \"\"\"\n        constructor\n        \"\"\"\n        self.debug = debug\n        self.gsearch = GoogleSearch()\n        self.ysearch = YahooSearch()\n        self.bsearch = BingSearch()\n        self.dsearch = DuckDuckGoSearch()\n        self.gs_search = GoogleScholarSearch()\n        self.engines = [self.gs_search, self.ysearch, self.dsearch, self.bsearch]\n\n    def handleException(self, ex):\n        \"\"\"\n        handle the given exception\n        \"\"\"\n        if self.debug:\n            print(f\"{str(ex)}\", file=sys.stderr)\n\n    def search(self, search_term: str):\n        \"\"\"\n        search my engines for the given search_term\n        \"\"\"\n        search_args = (search_term, 1)\n        for engine in self.engines:\n            try:\n                result = engine.search(*search_args)\n                yield engine.name, result.results\n                pass\n            except Exception as ex:\n                self.handleException(ex)\n                pass\n</code></pre>"},{"location":"#skg.searchengine.InternetSearch.__init__","title":"<code>__init__(debug=False)</code>","text":"<p>constructor</p> Source code in <code>skg/searchengine.py</code> <pre><code>def __init__(self, debug: bool = False):\n    \"\"\"\n    constructor\n    \"\"\"\n    self.debug = debug\n    self.gsearch = GoogleSearch()\n    self.ysearch = YahooSearch()\n    self.bsearch = BingSearch()\n    self.dsearch = DuckDuckGoSearch()\n    self.gs_search = GoogleScholarSearch()\n    self.engines = [self.gs_search, self.ysearch, self.dsearch, self.bsearch]\n</code></pre>"},{"location":"#skg.searchengine.InternetSearch.handleException","title":"<code>handleException(ex)</code>","text":"<p>handle the given exception</p> Source code in <code>skg/searchengine.py</code> <pre><code>def handleException(self, ex):\n    \"\"\"\n    handle the given exception\n    \"\"\"\n    if self.debug:\n        print(f\"{str(ex)}\", file=sys.stderr)\n</code></pre>"},{"location":"#skg.searchengine.InternetSearch.search","title":"<code>search(search_term)</code>","text":"<p>search my engines for the given search_term</p> Source code in <code>skg/searchengine.py</code> <pre><code>def search(self, search_term: str):\n    \"\"\"\n    search my engines for the given search_term\n    \"\"\"\n    search_args = (search_term, 1)\n    for engine in self.engines:\n        try:\n            result = engine.search(*search_args)\n            yield engine.name, result.results\n            pass\n        except Exception as ex:\n            self.handleException(ex)\n            pass\n</code></pre>"},{"location":"#skg.semantic_scholar","title":"<code>semantic_scholar</code>","text":"<p>Created on 2022-11-22</p> <p>@author: wf</p>"},{"location":"#skg.semantic_scholar.SemanticScholar","title":"<code>SemanticScholar</code>","text":"<p>wrapper for Semantic Scholar API</p> Source code in <code>skg/semantic_scholar.py</code> <pre><code>class SemanticScholar:\n    \"\"\"\n    wrapper for Semantic Scholar API\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        constructor\n        \"\"\"\n        self.sch = SemScholar()\n\n    def get_paper(self, doi: str):\n        \"\"\"\n        get the paper with the given DOI identifier\n        \"\"\"\n        paper = self.sch.get_paper(doi)\n        return paper\n\n    def get_author(self):\n        \"\"\"\n        https://api.semanticscholar.org/api-docs/graph#tag/Author-Data/operation/get_graph_get_author_search\n        \"\"\"\n        pass\n</code></pre>"},{"location":"#skg.semantic_scholar.SemanticScholar.__init__","title":"<code>__init__()</code>","text":"<p>constructor</p> Source code in <code>skg/semantic_scholar.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    constructor\n    \"\"\"\n    self.sch = SemScholar()\n</code></pre>"},{"location":"#skg.semantic_scholar.SemanticScholar.get_author","title":"<code>get_author()</code>","text":"<p>https://api.semanticscholar.org/api-docs/graph#tag/Author-Data/operation/get_graph_get_author_search</p> Source code in <code>skg/semantic_scholar.py</code> <pre><code>def get_author(self):\n    \"\"\"\n    https://api.semanticscholar.org/api-docs/graph#tag/Author-Data/operation/get_graph_get_author_search\n    \"\"\"\n    pass\n</code></pre>"},{"location":"#skg.semantic_scholar.SemanticScholar.get_paper","title":"<code>get_paper(doi)</code>","text":"<p>get the paper with the given DOI identifier</p> Source code in <code>skg/semantic_scholar.py</code> <pre><code>def get_paper(self, doi: str):\n    \"\"\"\n    get the paper with the given DOI identifier\n    \"\"\"\n    paper = self.sch.get_paper(doi)\n    return paper\n</code></pre>"},{"location":"#skg.skgbrowser","title":"<code>skgbrowser</code>","text":"<p>Created on 2022-11-18</p> <p>@author: wf</p>"},{"location":"#skg.skgbrowser.SkgBrowser","title":"<code>SkgBrowser</code>","text":"<p>               Bases: <code>InputWebserver</code></p> <p>scholary knowledge graph browser</p> Source code in <code>skg/skgbrowser.py</code> <pre><code>class SkgBrowser(InputWebserver):\n    \"\"\"\n    scholary knowledge graph browser\n    \"\"\"\n\n    @classmethod\n    def get_config(cls) -&gt; WebserverConfig:\n        copy_right = \"(c)2022-2024 Wolfgang Fahl\"\n        config = WebserverConfig(\n            copy_right=copy_right,\n            version=Version(),\n            default_port=8765,\n            short_name=\"sotsog\",\n        )\n        server_config = WebserverConfig.get(config)\n        server_config.solution_class = SkgSolution\n        return server_config\n\n    def __init__(self):\n        \"\"\"Constructs all the necessary attributes for the WebServer object.\"\"\"\n        config = SkgBrowser.get_config()\n        InputWebserver.__init__(self, config=config)\n\n        @ui.page(\"/scholars\")\n        async def scholars(client: Client):\n            return await self.page(client, SkgSolution.scholars)\n\n    def configure_run(self):\n        # wiki users\n        self.wikiUsers = WikiUser.getWikiUsers()\n        self.wikiId = self.args.wikiId\n        wikidata = Wikidata()\n        self.sparql = wikidata.sparql\n</code></pre>"},{"location":"#skg.skgbrowser.SkgBrowser.__init__","title":"<code>__init__()</code>","text":"<p>Constructs all the necessary attributes for the WebServer object.</p> Source code in <code>skg/skgbrowser.py</code> <pre><code>def __init__(self):\n    \"\"\"Constructs all the necessary attributes for the WebServer object.\"\"\"\n    config = SkgBrowser.get_config()\n    InputWebserver.__init__(self, config=config)\n\n    @ui.page(\"/scholars\")\n    async def scholars(client: Client):\n        return await self.page(client, SkgSolution.scholars)\n</code></pre>"},{"location":"#skg.skgbrowser.SkgSolution","title":"<code>SkgSolution(InputWebSolution)</code>","text":"<p>the scholarly knowledge graph solution</p> Source code in <code>skg/skgbrowser.py</code> <pre><code>def SkgSolution(InputWebSolution):\n    \"\"\"\n    the scholarly knowledge graph solution\n    \"\"\"\n\n    def __init__(self, webserver: SkgBrowser, client: Client):\n        \"\"\"\n        Initialize the solution\n\n        Calls the constructor of the base solution\n        Args:\n            webserver (SkgBrowser): The webserver instance associated with this context.\n            client (Client): The client instance this context is associated with.\n        \"\"\"\n        super().__init__(webserver, client)  # Call to the superclass constructor\n        self.language = \"en\"\n        self.wikiId = \"or\"\n        self.markup_names = [\"-\", \"bibtex\", \"scite\", \"smw\"]\n        self.markup_name = self.markup_names[1]\n\n    def configure_menu(self):\n        \"\"\"\n        configure additional non-standard menu entries\n        \"\"\"\n        # self.link_button(name='Scholars',icon_name='account-school',target='/scholars')\n        pass\n\n    def createItemLink(self, item, term: str, index: int) -&gt; str:\n        \"\"\"\n        create a link for the given item\n\n        Args:\n            item(Node): the item to create a link for\n            term(str): the\n        \"\"\"\n        if index &gt; 0:\n            style = \"color:grey\"\n            text = f\"{term}&lt;sub&gt;{index+1}&lt;/sub&gt;\"\n            delim = \"&amp;nbsp\"\n        else:\n            style = \"\"\n            text = term\n            delim = \"\"\n        link = Link.create(\n            item.browser_url(), text, tooltip=item.label, target=\"_blank\", style=style\n        )\n        if item.concept.name == \"Scholar\":\n            if hasattr(item, \"orcid\"):\n                orcid = ORCID(item.orcid)\n                link += orcid.asHtml()\n        markup = delim + link\n        return markup\n\n    async def onSearchButton(self, _msg):\n        \"\"\"\n        handle button to search for terms\n        \"\"\"\n        try:\n            self.results.content = \"\"\n            self.markup.content = \"\"\n            terms = self.searchTerms.value.split(\"\\n\")\n            self.messages.content = \"Searching\"\n            delim = \"\"\n            for term in terms:\n                if term:\n                    msg = f\"... {term}\\n\"\n                    self.messages.content += msg\n                    if self.markup_name == \"-\":\n                        self.options.markup_names = []\n                    else:\n                        self.options.markup_names = [self.markup_name]\n                    search_result = self.sotsog.search([term], self.options)\n                    items = search_result.items\n                    rmarkup = \"\"\n                    if len(items) == 0:\n                        # TODO check google search\n                        # https://pypi.org/project/googlesearch-python/\n                        params = parse.urlencode({\"q\": term})\n                        search_url = f\"https://www.google.com/search?{params}\"\n                        rmarkup = Link.create(\n                            search_url,\n                            term,\n                            \"not found\",\n                            target=\"_blank\",\n                            style=\"color:red\",\n                        )\n                    else:\n                        for i, item in enumerate(items):\n                            rmarkup += self.createItemLink(item, term, i)\n                            if len(item.markups) &gt; 0:\n                                markups = \"\"\n                                for _markup_name, markup in item.markups.items():\n                                    markups += markup\n                                    self.markup.content += f\"&lt;pre&gt;{markups}&lt;/pre&gt;\"\n                                    # break\n                    self.results.content += delim + rmarkup\n                    delim = \"&lt;br&gt;\"\n\n        except BaseException as ex:\n            self.handle_exception(ex)\n\n    def addLanguageSelect(self):\n        \"\"\"\n        add a language selector\n        \"\"\"\n        lang_dict = Lang.get_language_dict()\n        self.add_select(\"language:\", lang_dict).bind_value(self, \"language\")\n\n    def addWikiUserSelect(self):\n        \"\"\"\n        add a wiki user selector\n        \"\"\"\n        if len(self.wikiUsers) &gt; 0:\n            wu_dict = {}\n            for wikiUser in sorted(self.wikiUsers):\n                wu_dict[wikiUser] = wikiUser\n            self.add_select(\"wiki:\", wu_dict).bind_value(self, \"wikiId\")\n\n    async def scholars(self, client: Client):\n        \"\"\"\n        scholar display\n\n        \"\"\"\n        self.setup_menu()\n        with ui.element(\"div\").classes(\"w-full h-full\"):\n            try:\n                self.scholarsGrid = ScholarGrid(\n                    self, self.wikiUsers, self.wikiId, sparql=self.sparql\n                )\n                # @TODO refactor the two setup calls to one to hide wdgrid details\n                # self.scholarsGrid.setup(a=self.rowB, header=self.rowA)\n                # self.scholarsGrid.wdgrid.setup(a=self.rowC)\n            except BaseException as ex:\n                self.handle_exception(ex)\n        await self.setup_footer()\n\n    def configure_settings(self):\n        \"\"\"\n        configure settings\n        \"\"\"\n        self.addLanguageSelect()\n        self.addWikiUserSelect()\n\n    async def home(self, _client: Client):\n        \"\"\"\n        provide the main content page\n\n        \"\"\"\n        self.setup_menu()\n        with ui.element(\"div\").classes(\"w-full h-full\"):\n            with ui.splitter() as splitter:\n                with splitter.before:\n                    self.add_select(\"markup\", self.markup_names).bind_value(\n                        self, \"markup_name\"\n                    )\n                    self.searchTerms = ui.textarea(placeholder=\"enter search terms\")\n                    self.searchButton = ui.button(\n                        \"search\", on_click=self.onSearchButton\n                    )\n                with splitter.after:\n                    self.markup = ui.html()\n            self.messages = ui.html()\n            self.results = ui.html()\n        await self.setup_footer()\n</code></pre>"},{"location":"#skg.smw","title":"<code>smw</code>","text":"<p>Created on 22.11.2022</p> <p>@author: wf</p>"},{"location":"#skg.smw.SemWiki","title":"<code>SemWiki</code>","text":"<p>access to Semantic mediawiki</p> Source code in <code>skg/smw.py</code> <pre><code>class SemWiki:\n    \"\"\"\n    access to Semantic mediawiki\n    \"\"\"\n\n    def __init__(self, wikiUser: WikiUser, withLogin: bool = None):\n        \"\"\"\n\n        constructor\n\n        Args:\n            wikiUser:WikiUser\n        \"\"\"\n        self.wikiUser = wikiUser\n        self.wikiClient = WikiClient.ofWikiId(wikiUser.wikiId)\n        if withLogin is None:\n            withLogin = self.wikiClient.needsLogin()\n        if withLogin:\n            self.wikiClient.login()\n        self.smw = SMWClient(self.wikiClient.getSite())\n\n    def id_refs(\n        self,\n        mainlabel=\"pageTitle\",\n        condition=\"DOI::+\",\n        title: str = \"DOI references\",\n        askExtra: str = \"\",\n        id_prop=\"DOI\",\n        id_name=\"doi\",\n    ) -&gt; list:\n        \"\"\"\n        get a list of id references from the given wiki\n\n        Args:\n            mainlabel(str): the mainlabel to use\n            condition(str): the condition to apply\n            title(str): the title of the query\n        \"\"\"\n        ask = f\"\"\"{{{{#ask:[[{condition}]]{askExtra}\n|?{id_prop}={id_name}\n|mainlabel={mainlabel}\n|?Creation_date=creationDate\n|?Modification_date=modificationDate\n|?Last_editor_is=lastEditor\n}}}}\n\"\"\"\n        refs = self.smw.query(ask, title)\n        return refs\n\n    def papers(self):\n        \"\"\"\n        get the paper records\n        \"\"\"\n        askExtra = \"\"\"\\n|?Citation_text=reference\"\"\"\n        paper_records = self.id_refs(\n            condition=\"Citation_text::+\", title=\"doi paper referencs\", askExtra=askExtra\n        )\n        return paper_records\n\n    def scholars(self):\n        \"\"\"\n        get scholars\n        \"\"\"\n        condition = \"Concept:Scholar\"\n        mainlabel = \"Scholar\"\n        askExtra = \"\"\"|?Scholar wikiDataId = wikiDataId\n|?Scholar name = name\n|?Scholar firstName = firstName\n|?Scholar description = description\n|?Scholar homepage = homepage\n|?Scholar orcid = orcid\n|?Scholar dblpId = dblpId\n|?Scholar linkedInId = linkedInId\n|?Scholar researchGate = researchGate\n|?Scholar gndId = gndId\n|?Scholar smartCRMId = smartCRMId\n|sort=Scholar name,Scholar firstName\n|order=ascending,ascending\n\"\"\"\n        scholars = self.id_refs(\n            mainlabel,\n            condition,\n            \"scholars\",\n            askExtra,\n            \"Scholar wikiDataId\",\n            \"wikiDataId\",\n        )\n        return scholars\n\n    @classmethod\n    def asMarkup(self, scholar) -&gt; str:\n        \"\"\"\n        return the markup for the given scholar\n\n        Args:\n            scholar(Node): the scholar\n        Returns:\n            str: the semantic mediawiki markup\n        \"\"\"\n        markup = \"{{Scholar\"\n\n        for prop_name, prop in scholar.concept.props.items():\n            if prop.hasmap(\"smw\"):\n                smw_prop = prop.getmap(\"smw\")\n                if hasattr(scholar, prop_name):\n                    value = getattr(scholar, prop_name)\n                    # @TODO refactor\n                    qid = Wikidata.getQid(value)\n                    if value != qid:\n                        # potential lookup need\n                        if prop_name != \"wikiDataId\":\n                            value = Wikidata.getLabelForQid(qid)\n                        else:\n                            value = qid\n                    markup += f\"\\n|{smw_prop}={value}\"\n        markup += \"\\n}}\"\n        return markup\n</code></pre>"},{"location":"#skg.smw.SemWiki.__init__","title":"<code>__init__(wikiUser, withLogin=None)</code>","text":"<p>constructor</p> <p>Parameters:</p> Name Type Description Default <code>wikiUser</code> <code>WikiUser</code> <p>WikiUser</p> required Source code in <code>skg/smw.py</code> <pre><code>def __init__(self, wikiUser: WikiUser, withLogin: bool = None):\n    \"\"\"\n\n    constructor\n\n    Args:\n        wikiUser:WikiUser\n    \"\"\"\n    self.wikiUser = wikiUser\n    self.wikiClient = WikiClient.ofWikiId(wikiUser.wikiId)\n    if withLogin is None:\n        withLogin = self.wikiClient.needsLogin()\n    if withLogin:\n        self.wikiClient.login()\n    self.smw = SMWClient(self.wikiClient.getSite())\n</code></pre>"},{"location":"#skg.smw.SemWiki.asMarkup","title":"<code>asMarkup(scholar)</code>  <code>classmethod</code>","text":"<p>return the markup for the given scholar</p> <p>Parameters:</p> Name Type Description Default <code>scholar(Node)</code> <p>the scholar</p> required <p>Returns:     str: the semantic mediawiki markup</p> Source code in <code>skg/smw.py</code> <pre><code>@classmethod\ndef asMarkup(self, scholar) -&gt; str:\n    \"\"\"\n    return the markup for the given scholar\n\n    Args:\n        scholar(Node): the scholar\n    Returns:\n        str: the semantic mediawiki markup\n    \"\"\"\n    markup = \"{{Scholar\"\n\n    for prop_name, prop in scholar.concept.props.items():\n        if prop.hasmap(\"smw\"):\n            smw_prop = prop.getmap(\"smw\")\n            if hasattr(scholar, prop_name):\n                value = getattr(scholar, prop_name)\n                # @TODO refactor\n                qid = Wikidata.getQid(value)\n                if value != qid:\n                    # potential lookup need\n                    if prop_name != \"wikiDataId\":\n                        value = Wikidata.getLabelForQid(qid)\n                    else:\n                        value = qid\n                markup += f\"\\n|{smw_prop}={value}\"\n    markup += \"\\n}}\"\n    return markup\n</code></pre>"},{"location":"#skg.smw.SemWiki.id_refs","title":"<code>id_refs(mainlabel='pageTitle', condition='DOI::+', title='DOI references', askExtra='', id_prop='DOI', id_name='doi')</code>","text":"<p>get a list of id references from the given wiki</p> <p>Parameters:</p> Name Type Description Default <code>mainlabel(str)</code> <p>the mainlabel to use</p> required <code>condition(str)</code> <p>the condition to apply</p> required <code>title(str)</code> <p>the title of the query</p> required Source code in <code>skg/smw.py</code> <pre><code>    def id_refs(\n        self,\n        mainlabel=\"pageTitle\",\n        condition=\"DOI::+\",\n        title: str = \"DOI references\",\n        askExtra: str = \"\",\n        id_prop=\"DOI\",\n        id_name=\"doi\",\n    ) -&gt; list:\n        \"\"\"\n        get a list of id references from the given wiki\n\n        Args:\n            mainlabel(str): the mainlabel to use\n            condition(str): the condition to apply\n            title(str): the title of the query\n        \"\"\"\n        ask = f\"\"\"{{{{#ask:[[{condition}]]{askExtra}\n|?{id_prop}={id_name}\n|mainlabel={mainlabel}\n|?Creation_date=creationDate\n|?Modification_date=modificationDate\n|?Last_editor_is=lastEditor\n}}}}\n\"\"\"\n        refs = self.smw.query(ask, title)\n        return refs\n</code></pre>"},{"location":"#skg.smw.SemWiki.papers","title":"<code>papers()</code>","text":"<p>get the paper records</p> Source code in <code>skg/smw.py</code> <pre><code>def papers(self):\n    \"\"\"\n    get the paper records\n    \"\"\"\n    askExtra = \"\"\"\\n|?Citation_text=reference\"\"\"\n    paper_records = self.id_refs(\n        condition=\"Citation_text::+\", title=\"doi paper referencs\", askExtra=askExtra\n    )\n    return paper_records\n</code></pre>"},{"location":"#skg.smw.SemWiki.scholars","title":"<code>scholars()</code>","text":"<p>get scholars</p> Source code in <code>skg/smw.py</code> <pre><code>    def scholars(self):\n        \"\"\"\n        get scholars\n        \"\"\"\n        condition = \"Concept:Scholar\"\n        mainlabel = \"Scholar\"\n        askExtra = \"\"\"|?Scholar wikiDataId = wikiDataId\n|?Scholar name = name\n|?Scholar firstName = firstName\n|?Scholar description = description\n|?Scholar homepage = homepage\n|?Scholar orcid = orcid\n|?Scholar dblpId = dblpId\n|?Scholar linkedInId = linkedInId\n|?Scholar researchGate = researchGate\n|?Scholar gndId = gndId\n|?Scholar smartCRMId = smartCRMId\n|sort=Scholar name,Scholar firstName\n|order=ascending,ascending\n\"\"\"\n        scholars = self.id_refs(\n            mainlabel,\n            condition,\n            \"scholars\",\n            askExtra,\n            \"Scholar wikiDataId\",\n            \"wikiDataId\",\n        )\n        return scholars\n</code></pre>"},{"location":"#skg.sotsog","title":"<code>sotsog</code>","text":"<p>Created on 2022-11-16</p> <p>@author: wf</p>"},{"location":"#skg.sotsog.SotSog","title":"<code>SotSog</code>","text":"<p>Standing on the shoulders of giants</p> Source code in <code>skg/sotsog.py</code> <pre><code>class SotSog:\n    \"\"\"\n    Standing on the shoulders of giants\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        constructor\n\n        \"\"\"\n        Node.debug = self.debug\n        self.wikipedia_url = (\n            \"https://en.wikipedia.org/wiki/Standing_on_the_shoulders_of_giants\"\n        )\n        self.skg_def = SKG_Def()\n        self.scholar_concept = self.skg_def.concepts[\"Scholar\"]\n\n    def getMarkups(self, item, options: SearchOptions) -&gt; dict:\n        \"\"\"\n        get the markups for the given item and search options\n\n        Args:\n            item(Node): the item to get the markup for\n            options(SearchOptions): the search options to apply\n        \"\"\"\n        markups = {}\n        do_markup = len(options.markup_names) &gt; 0\n        if do_markup:\n            if item.concept.name == \"Paper\":\n                doi = getattr(item, \"doi\", None)\n                if doi is not None:\n                    crossref = Crossref()\n                    if \"bibtex\" in options.markup_names:\n                        bibentry = crossref.doiBibEntry([doi])\n                        markups[\"bibtex\"] = bibentry\n                    if \"scite\" in options.markup_names:\n                        # meta_data=crossref.doiMetaData([doi])\n                        # scite_entry=crossref.asScite(meta_data)\n                        if not hasattr(item, \"doi_obj\"):\n                            item.fromDOI(doi)\n                        scite_entry = item.doi_obj.asScite()\n                        markups[\"scite\"] = scite_entry\n            if item.concept.name == \"Scholar\":\n                if \"smw\" in options.markup_names:\n                    markups[\"smw\"] = SemWiki.asMarkup(item)\n        return markups\n\n    def wd_search(self, wd: Wikidata, search_term: str, options) -&gt; list:\n        \"\"\"\n        do a wikidata search\n        \"\"\"\n        items = []\n        wds = WikidataSearch(language=options.lang, debug=self.debug)\n        search_options = wds.searchOptions(search_term, limit=options.limit)\n        qids = []\n        for qid, itemLabel, desc in search_options:\n            qids.append(qid)\n        class_map = wd.getClassQids(qids)\n        for qid, itemLabel, desc in search_options:\n            if qid in class_map:\n                class_rows = class_map[qid]\n                for class_row in class_rows:\n                    class_qid = class_row[\"class_qid\"]\n                    concept = self.skg_def.conceptForQid(class_qid)\n                    if concept is not None:\n                        wd_items = concept.cls.from_wikidata_via_id(\n                            concept, \"wikiDataId\", qid, lang=options.lang\n                        )\n                        if len(wd_items) &gt; 0:\n                            item = wd_items[0]\n                            items.append(item)\n                            self.handleItem(item, qid, itemLabel, desc, options)\n        return items\n\n    def handleItem(self, item, item_id, itemLabel, desc, options):\n        \"\"\"\n        handle the given item as a search result\n        \"\"\"\n        if options.show:\n            print(f\"{itemLabel}({item_id}):{desc}\u2705\")\n            print(item)\n        item.markups = self.getMarkups(item, options)\n        if options.show:\n            for markup_name, markup in item.markups.items():\n                print(f\"{markup_name} markup:\")\n                print(markup)\n            pass\n        if options.open_browser:\n            browser_url = item.browser_url()\n            if browser_url is not None:\n                print(f\"opening {browser_url} in browser\")\n                webbrowser.open(browser_url)\n\n    def handleItems(self, items, options):\n        \"\"\"\n        handle the given items\n        \"\"\"\n        for item in items:\n            item_id = item.wikiDataId\n            itemLabel = item.label\n            desc = \"?\"\n            self.handleItem(item, item_id, itemLabel, desc, options)\n\n    def handleDoiItem(self, item, options: SearchOptions):\n        item_id = item.doi\n        itemLabel = item.title\n        desc = item.title\n        self.handleItem(item, item_id, itemLabel, desc, options)\n\n    def search(self, search_list, options: SearchOptions) -&gt; SearchResult:\n        \"\"\"\n        search with the given search list\n\n        Args:\n            search_list(list): a list of search terms\n            options(SearchOptions): the search options to apply\n        \"\"\"\n        search_result = SearchResult(search_list, options)\n        search_term = \" \".join(search_list)\n        for prefix in [\"https://doi.org\"]:\n            if search_term.startswith(prefix):\n                search_term = search_term.replace(prefix, \"\")\n        wd = Wikidata(debug=self.debug)\n        if ORCID.isORCID(search_term):\n            scholar_concept = self.skg_def.concepts[\"Scholar\"]\n            items = Node.from_wikidata_via_id(\n                scholar_concept, \"orcid\", search_term, options.lang\n            )\n            self.handleItems(items, options)\n        elif DOI.isDOI(search_term):\n            # DOI may not be referencing paper but something else\n            paper_concept = self.skg_def.concepts[\"Paper\"]\n            items = Paper.from_wikidata_via_id(\n                paper_concept, \"doi\", search_term, options.lang\n            )\n            self.handleItems(items, options)\n            dblp_items = Paper.from_dblp_via_id(\n                paper_concept, \"doi\", search_term.lower()\n            )\n            if len(dblp_items) == 0:\n                paper = Paper()\n                paper.concept = paper_concept\n                paper.fromDOI(search_term)\n                paper.provenance = \"doi\"\n                dblp_items = [paper]\n            for item in dblp_items:\n                self.handleDoiItem(item, options)\n            items.extend(dblp_items)\n        else:\n            items = self.wd_search(wd, search_term, options)\n        search_result.items = items\n        return search_result\n</code></pre>"},{"location":"#skg.sotsog.SotSog.__init__","title":"<code>__init__()</code>","text":"<p>constructor</p> Source code in <code>skg/sotsog.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    constructor\n\n    \"\"\"\n    Node.debug = self.debug\n    self.wikipedia_url = (\n        \"https://en.wikipedia.org/wiki/Standing_on_the_shoulders_of_giants\"\n    )\n    self.skg_def = SKG_Def()\n    self.scholar_concept = self.skg_def.concepts[\"Scholar\"]\n</code></pre>"},{"location":"#skg.sotsog.SotSog.getMarkups","title":"<code>getMarkups(item, options)</code>","text":"<p>get the markups for the given item and search options</p> <p>Parameters:</p> Name Type Description Default <code>item(Node)</code> <p>the item to get the markup for</p> required <code>options(SearchOptions)</code> <p>the search options to apply</p> required Source code in <code>skg/sotsog.py</code> <pre><code>def getMarkups(self, item, options: SearchOptions) -&gt; dict:\n    \"\"\"\n    get the markups for the given item and search options\n\n    Args:\n        item(Node): the item to get the markup for\n        options(SearchOptions): the search options to apply\n    \"\"\"\n    markups = {}\n    do_markup = len(options.markup_names) &gt; 0\n    if do_markup:\n        if item.concept.name == \"Paper\":\n            doi = getattr(item, \"doi\", None)\n            if doi is not None:\n                crossref = Crossref()\n                if \"bibtex\" in options.markup_names:\n                    bibentry = crossref.doiBibEntry([doi])\n                    markups[\"bibtex\"] = bibentry\n                if \"scite\" in options.markup_names:\n                    # meta_data=crossref.doiMetaData([doi])\n                    # scite_entry=crossref.asScite(meta_data)\n                    if not hasattr(item, \"doi_obj\"):\n                        item.fromDOI(doi)\n                    scite_entry = item.doi_obj.asScite()\n                    markups[\"scite\"] = scite_entry\n        if item.concept.name == \"Scholar\":\n            if \"smw\" in options.markup_names:\n                markups[\"smw\"] = SemWiki.asMarkup(item)\n    return markups\n</code></pre>"},{"location":"#skg.sotsog.SotSog.handleItem","title":"<code>handleItem(item, item_id, itemLabel, desc, options)</code>","text":"<p>handle the given item as a search result</p> Source code in <code>skg/sotsog.py</code> <pre><code>def handleItem(self, item, item_id, itemLabel, desc, options):\n    \"\"\"\n    handle the given item as a search result\n    \"\"\"\n    if options.show:\n        print(f\"{itemLabel}({item_id}):{desc}\u2705\")\n        print(item)\n    item.markups = self.getMarkups(item, options)\n    if options.show:\n        for markup_name, markup in item.markups.items():\n            print(f\"{markup_name} markup:\")\n            print(markup)\n        pass\n    if options.open_browser:\n        browser_url = item.browser_url()\n        if browser_url is not None:\n            print(f\"opening {browser_url} in browser\")\n            webbrowser.open(browser_url)\n</code></pre>"},{"location":"#skg.sotsog.SotSog.handleItems","title":"<code>handleItems(items, options)</code>","text":"<p>handle the given items</p> Source code in <code>skg/sotsog.py</code> <pre><code>def handleItems(self, items, options):\n    \"\"\"\n    handle the given items\n    \"\"\"\n    for item in items:\n        item_id = item.wikiDataId\n        itemLabel = item.label\n        desc = \"?\"\n        self.handleItem(item, item_id, itemLabel, desc, options)\n</code></pre>"},{"location":"#skg.sotsog.SotSog.search","title":"<code>search(search_list, options)</code>","text":"<p>search with the given search list</p> <p>Parameters:</p> Name Type Description Default <code>search_list(list)</code> <p>a list of search terms</p> required <code>options(SearchOptions)</code> <p>the search options to apply</p> required Source code in <code>skg/sotsog.py</code> <pre><code>def search(self, search_list, options: SearchOptions) -&gt; SearchResult:\n    \"\"\"\n    search with the given search list\n\n    Args:\n        search_list(list): a list of search terms\n        options(SearchOptions): the search options to apply\n    \"\"\"\n    search_result = SearchResult(search_list, options)\n    search_term = \" \".join(search_list)\n    for prefix in [\"https://doi.org\"]:\n        if search_term.startswith(prefix):\n            search_term = search_term.replace(prefix, \"\")\n    wd = Wikidata(debug=self.debug)\n    if ORCID.isORCID(search_term):\n        scholar_concept = self.skg_def.concepts[\"Scholar\"]\n        items = Node.from_wikidata_via_id(\n            scholar_concept, \"orcid\", search_term, options.lang\n        )\n        self.handleItems(items, options)\n    elif DOI.isDOI(search_term):\n        # DOI may not be referencing paper but something else\n        paper_concept = self.skg_def.concepts[\"Paper\"]\n        items = Paper.from_wikidata_via_id(\n            paper_concept, \"doi\", search_term, options.lang\n        )\n        self.handleItems(items, options)\n        dblp_items = Paper.from_dblp_via_id(\n            paper_concept, \"doi\", search_term.lower()\n        )\n        if len(dblp_items) == 0:\n            paper = Paper()\n            paper.concept = paper_concept\n            paper.fromDOI(search_term)\n            paper.provenance = \"doi\"\n            dblp_items = [paper]\n        for item in dblp_items:\n            self.handleDoiItem(item, options)\n        items.extend(dblp_items)\n    else:\n        items = self.wd_search(wd, search_term, options)\n    search_result.items = items\n    return search_result\n</code></pre>"},{"location":"#skg.sotsog.SotSog.wd_search","title":"<code>wd_search(wd, search_term, options)</code>","text":"<p>do a wikidata search</p> Source code in <code>skg/sotsog.py</code> <pre><code>def wd_search(self, wd: Wikidata, search_term: str, options) -&gt; list:\n    \"\"\"\n    do a wikidata search\n    \"\"\"\n    items = []\n    wds = WikidataSearch(language=options.lang, debug=self.debug)\n    search_options = wds.searchOptions(search_term, limit=options.limit)\n    qids = []\n    for qid, itemLabel, desc in search_options:\n        qids.append(qid)\n    class_map = wd.getClassQids(qids)\n    for qid, itemLabel, desc in search_options:\n        if qid in class_map:\n            class_rows = class_map[qid]\n            for class_row in class_rows:\n                class_qid = class_row[\"class_qid\"]\n                concept = self.skg_def.conceptForQid(class_qid)\n                if concept is not None:\n                    wd_items = concept.cls.from_wikidata_via_id(\n                        concept, \"wikiDataId\", qid, lang=options.lang\n                    )\n                    if len(wd_items) &gt; 0:\n                        item = wd_items[0]\n                        items.append(item)\n                        self.handleItem(item, qid, itemLabel, desc, options)\n    return items\n</code></pre>"},{"location":"#skg.sotsog_cmd","title":"<code>sotsog_cmd</code>","text":"<p>Created on 2024-02-26</p> <p>@author: wf</p>"},{"location":"#skg.sotsog_cmd.SotSogCmd","title":"<code>SotSogCmd</code>","text":"<p>               Bases: <code>WebserverCmd</code></p> <p>command line handling for Standing on the Shoulders of Giants</p> Source code in <code>skg/sotsog_cmd.py</code> <pre><code>class SotSogCmd(WebserverCmd):\n    \"\"\"\n    command line handling for Standing on the Shoulders of Giants\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        constructor\n        \"\"\"\n        self.config = SkgBrowser.get_config()\n        WebserverCmd.__init__(self, self.config, SkgBrowser, DEBUG)\n\n    def getArgParser(self, description: str, version_msg) -&gt; ArgumentParser:\n        \"\"\"\n        override the default argparser call\n        \"\"\"\n        parser = super().getArgParser(description, version_msg)\n        parser.add_argument(\"search\", action=\"store\", nargs=\"*\", help=\"search terms\")\n        parser.add_argument(\n            \"--bibtex\", help=\"output bibtex format\", action=\"store_true\"\n        )\n        parser.add_argument(\"-la\", \"--lang\", help=\"language code to use\", default=\"en\")\n        parser.add_argument(\n            \"-li\",\n            \"--limit\",\n            help=\"limit the number of search results\",\n            type=int,\n            default=9,\n        )\n        parser.add_argument(\n            \"-nb\", \"--nobrowser\", help=\"do not open browser\", action=\"store_true\"\n        )\n        parser.add_argument(\"--scite\", help=\"output #scite format\", action=\"store_true\")\n        parser.add_argument(\n            \"--smw\", help=\"output Semantic MediaWiki (SMW) format\", action=\"store_true\"\n        )\n        parser.add_argument(\n            \"--wikiId\", help=\"the id of the SMW wiki to connect with\", default=\"ceur-ws\"\n        )\n        parser.add_argument(\n            \"-dw\",\n            \"--dblp2wikidata\",\n            action=\"store_true\",\n            help=\"Synchronize DBLP entries with Wikidata\",\n        )\n\n        return parser\n\n    def handle_args(self) -&gt; bool:\n        \"\"\"\n        handle the command line args\n        \"\"\"\n        markup_names = []\n        args = self.args\n        self.sotsog = SotSog(debug=args.debug)\n        if args.bibtex:\n            markup_names.append(\"bibtex\")\n        if args.scite:\n            markup_names.append(\"scite\")\n        if args.smw:\n            markup_names.append(\"smw\")\n        self.sotsog.options = SearchOptions(\n            limit=args.limit,\n            lang=args.lang,\n            markup_names=markup_names,\n            open_browser=not args.nobrowser,\n        )\n        handled = super().handle_args()\n        if not handled:\n            if args.dblp2wikidata:\n                d2w = Dblp2Wikidata()\n                handled = d2w.transfer(args)\n        if not handled:\n            self.search(args.search, self.sotsog.options)\n            handled = True\n        return handled\n</code></pre>"},{"location":"#skg.sotsog_cmd.SotSogCmd.__init__","title":"<code>__init__()</code>","text":"<p>constructor</p> Source code in <code>skg/sotsog_cmd.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    constructor\n    \"\"\"\n    self.config = SkgBrowser.get_config()\n    WebserverCmd.__init__(self, self.config, SkgBrowser, DEBUG)\n</code></pre>"},{"location":"#skg.sotsog_cmd.SotSogCmd.getArgParser","title":"<code>getArgParser(description, version_msg)</code>","text":"<p>override the default argparser call</p> Source code in <code>skg/sotsog_cmd.py</code> <pre><code>def getArgParser(self, description: str, version_msg) -&gt; ArgumentParser:\n    \"\"\"\n    override the default argparser call\n    \"\"\"\n    parser = super().getArgParser(description, version_msg)\n    parser.add_argument(\"search\", action=\"store\", nargs=\"*\", help=\"search terms\")\n    parser.add_argument(\n        \"--bibtex\", help=\"output bibtex format\", action=\"store_true\"\n    )\n    parser.add_argument(\"-la\", \"--lang\", help=\"language code to use\", default=\"en\")\n    parser.add_argument(\n        \"-li\",\n        \"--limit\",\n        help=\"limit the number of search results\",\n        type=int,\n        default=9,\n    )\n    parser.add_argument(\n        \"-nb\", \"--nobrowser\", help=\"do not open browser\", action=\"store_true\"\n    )\n    parser.add_argument(\"--scite\", help=\"output #scite format\", action=\"store_true\")\n    parser.add_argument(\n        \"--smw\", help=\"output Semantic MediaWiki (SMW) format\", action=\"store_true\"\n    )\n    parser.add_argument(\n        \"--wikiId\", help=\"the id of the SMW wiki to connect with\", default=\"ceur-ws\"\n    )\n    parser.add_argument(\n        \"-dw\",\n        \"--dblp2wikidata\",\n        action=\"store_true\",\n        help=\"Synchronize DBLP entries with Wikidata\",\n    )\n\n    return parser\n</code></pre>"},{"location":"#skg.sotsog_cmd.SotSogCmd.handle_args","title":"<code>handle_args()</code>","text":"<p>handle the command line args</p> Source code in <code>skg/sotsog_cmd.py</code> <pre><code>def handle_args(self) -&gt; bool:\n    \"\"\"\n    handle the command line args\n    \"\"\"\n    markup_names = []\n    args = self.args\n    self.sotsog = SotSog(debug=args.debug)\n    if args.bibtex:\n        markup_names.append(\"bibtex\")\n    if args.scite:\n        markup_names.append(\"scite\")\n    if args.smw:\n        markup_names.append(\"smw\")\n    self.sotsog.options = SearchOptions(\n        limit=args.limit,\n        lang=args.lang,\n        markup_names=markup_names,\n        open_browser=not args.nobrowser,\n    )\n    handled = super().handle_args()\n    if not handled:\n        if args.dblp2wikidata:\n            d2w = Dblp2Wikidata()\n            handled = d2w.transfer(args)\n    if not handled:\n        self.search(args.search, self.sotsog.options)\n        handled = True\n    return handled\n</code></pre>"},{"location":"#skg.sotsog_cmd.main","title":"<code>main(argv=None)</code>","text":"<p>main call</p> Source code in <code>skg/sotsog_cmd.py</code> <pre><code>def main(argv: list = None):\n    \"\"\"\n    main call\n    \"\"\"\n    cmd = SotSogCmd()\n    exit_code = cmd.cmd_main(argv)\n    return exit_code\n</code></pre>"},{"location":"#skg.version","title":"<code>version</code>","text":"<p>Created on 2022-04-01</p> <p>@author: wf</p>"},{"location":"#skg.version.Version","title":"<code>Version</code>","text":"<p>               Bases: <code>object</code></p> <p>Version handling for pysotsog</p> Source code in <code>skg/version.py</code> <pre><code>class Version(object):\n    \"\"\"\n    Version handling for pysotsog\n    \"\"\"\n\n    name = \"pysotsog\"\n    description = (\n        \"sotsog: Standing on the shoulders of giants - with direct access to the clouds\"\n    )\n    version = skg.__version__\n    date = \"2022-11-16\"\n    updated = \"2023-10-28\"\n    authors = \"Wolfgang Fahl\"\n    doc_url = \"https://wiki.bitplan.com/index.php/Pysotsog\"\n    chat_url = \"https://github.com/WolfgangFahl/pysotsog/discussions\"\n    cm_url = \"https://github.com/WolfgangFahl/pysotsog\"\n    license = f\"\"\"Copyright 2022 contributors. All rights reserved.\n  Licensed under the Apache License 2.0\n  http://www.apache.org/licenses/LICENSE-2.0\n  Distributed on an \"AS IS\" basis without warranties\n  or conditions of any kind, either express or implied.\"\"\"\n    longDescription = f\"\"\"{name} version {version}\n{description}\n  Created by {authors} on {date} last updated {updated}\"\"\"\n</code></pre>"},{"location":"#skg.wdsearch","title":"<code>wdsearch</code>","text":"<p>Created on 24.07.2022</p> <p>@author: wf</p>"},{"location":"#skg.wdsearch.WikidataSearch","title":"<code>WikidataSearch</code>","text":"<p>               Bases: <code>object</code></p> <p>Wikidata Search</p> Source code in <code>skg/wdsearch.py</code> <pre><code>class WikidataSearch(object):\n    \"\"\"\n    Wikidata Search\n    \"\"\"\n\n    def __init__(self, language=\"en\", timeout=2.0, debug: bool = False):\n        \"\"\"\n        Constructor\n\n        Args:\n            language(str): the language to use e.g. en/fr\n            timeout(float): maximum time to wait for result\n            debug(bool): if True debug details should be shown\n        \"\"\"\n        self.language = language\n        self.timeout = timeout\n        self.debug = debug\n\n    def searchOptions(self, searchFor: str, limit: int = 9) -&gt; list:\n        \"\"\"\n        search and return a list of qid,itemLabel description tuples\n\n        Args:\n            searchFor(str): the string to search for\n            limit(int): the maximum amount of results to search for\n        \"\"\"\n        options = []\n        srlist = self.search(searchFor, limit)\n        if srlist is not None:\n            for sr in srlist:\n                qid = sr[\"id\"]\n                itemLabel = sr[\"label\"]\n                desc = \"\"\n                if \"display\" in sr:\n                    display = sr[\"display\"]\n                    if \"description\" in display:\n                        desc = display[\"description\"][\"value\"]\n                options.append(\n                    (\n                        qid,\n                        itemLabel,\n                        desc,\n                    )\n                )\n        return options\n\n    def search(self, searchFor: str, limit: int = 9):\n        \"\"\"\n\n        Args:\n            searchFor(str): the string to search for\n            limit(int): the maximum amount of results to search for\n        \"\"\"\n        try:\n            apiurl = f\"https://www.wikidata.org/w/api.php?action=wbsearchentities&amp;language={self.language}&amp;format=json&amp;limit={limit}&amp;search=\"\n            if self.debug:\n                print(apiurl)\n            searchEncoded = urllib.parse.quote_plus(searchFor)\n            apisearch = apiurl + searchEncoded\n            with urllib.request.urlopen(apisearch, timeout=self.timeout) as url:\n                searchResult = json.loads(url.read().decode())\n            return searchResult[\"search\"]\n        except Exception as _error:\n            return None\n</code></pre>"},{"location":"#skg.wdsearch.WikidataSearch.__init__","title":"<code>__init__(language='en', timeout=2.0, debug=False)</code>","text":"<p>Constructor</p> <p>Parameters:</p> Name Type Description Default <code>language(str)</code> <p>the language to use e.g. en/fr</p> required <code>timeout(float)</code> <p>maximum time to wait for result</p> required <code>debug(bool)</code> <p>if True debug details should be shown</p> required Source code in <code>skg/wdsearch.py</code> <pre><code>def __init__(self, language=\"en\", timeout=2.0, debug: bool = False):\n    \"\"\"\n    Constructor\n\n    Args:\n        language(str): the language to use e.g. en/fr\n        timeout(float): maximum time to wait for result\n        debug(bool): if True debug details should be shown\n    \"\"\"\n    self.language = language\n    self.timeout = timeout\n    self.debug = debug\n</code></pre>"},{"location":"#skg.wdsearch.WikidataSearch.search","title":"<code>search(searchFor, limit=9)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>searchFor(str)</code> <p>the string to search for</p> required <code>limit(int)</code> <p>the maximum amount of results to search for</p> required Source code in <code>skg/wdsearch.py</code> <pre><code>def search(self, searchFor: str, limit: int = 9):\n    \"\"\"\n\n    Args:\n        searchFor(str): the string to search for\n        limit(int): the maximum amount of results to search for\n    \"\"\"\n    try:\n        apiurl = f\"https://www.wikidata.org/w/api.php?action=wbsearchentities&amp;language={self.language}&amp;format=json&amp;limit={limit}&amp;search=\"\n        if self.debug:\n            print(apiurl)\n        searchEncoded = urllib.parse.quote_plus(searchFor)\n        apisearch = apiurl + searchEncoded\n        with urllib.request.urlopen(apisearch, timeout=self.timeout) as url:\n            searchResult = json.loads(url.read().decode())\n        return searchResult[\"search\"]\n    except Exception as _error:\n        return None\n</code></pre>"},{"location":"#skg.wdsearch.WikidataSearch.searchOptions","title":"<code>searchOptions(searchFor, limit=9)</code>","text":"<p>search and return a list of qid,itemLabel description tuples</p> <p>Parameters:</p> Name Type Description Default <code>searchFor(str)</code> <p>the string to search for</p> required <code>limit(int)</code> <p>the maximum amount of results to search for</p> required Source code in <code>skg/wdsearch.py</code> <pre><code>def searchOptions(self, searchFor: str, limit: int = 9) -&gt; list:\n    \"\"\"\n    search and return a list of qid,itemLabel description tuples\n\n    Args:\n        searchFor(str): the string to search for\n        limit(int): the maximum amount of results to search for\n    \"\"\"\n    options = []\n    srlist = self.search(searchFor, limit)\n    if srlist is not None:\n        for sr in srlist:\n            qid = sr[\"id\"]\n            itemLabel = sr[\"label\"]\n            desc = \"\"\n            if \"display\" in sr:\n                display = sr[\"display\"]\n                if \"description\" in display:\n                    desc = display[\"description\"][\"value\"]\n            options.append(\n                (\n                    qid,\n                    itemLabel,\n                    desc,\n                )\n            )\n    return options\n</code></pre>"},{"location":"#skg.wikidata","title":"<code>wikidata</code>","text":"<p>Created on 2022-11-16</p> <p>@author: wf</p>"},{"location":"#skg.wikidata.Wikidata","title":"<code>Wikidata</code>","text":"<p>Wikidata access wrapper</p> Source code in <code>skg/wikidata.py</code> <pre><code>class Wikidata:\n    \"\"\"\n    Wikidata access wrapper\n    \"\"\"\n\n    instance = None\n\n    def __init__(\n        self, endpoint: str = \"https://query.wikidata.org/sparql\", debug: bool = False\n    ):\n        \"\"\"\n        constructor\n        \"\"\"\n        self.endpoint = endpoint\n        self.sparql = SPARQL(endpoint)\n        self.debug = debug\n        Wikidata.instance = self\n\n    @classmethod\n    def getInstance(cls):\n        if cls.instance is None:\n            Wikidata()\n        return cls.instance\n\n    @classmethod\n    def getQid(self, wd_url: str):\n        qid = wd_url.replace(\"http://www.wikidata.org/entity/\", \"\")\n        return qid\n\n    @classmethod\n    def getLabelForQid(self, qid: str, lang: str = \"en\") -&gt; str:\n        \"\"\"\n        get a label for the given Wikidata QID\n\n        Args:\n            qid(str): the Wikidata ID\n            lang(str): the language\n        \"\"\"\n        sparql_query = f\"\"\"SELECT ?itemLabel WHERE {{\n  VALUES ?item {{\n    wd:{qid}\n  }}\n  ?item rdfs:label ?itemLabel.\n  FILTER(LANG(?itemLabel)=\"{lang}\").\n}}\"\"\"\n        wd = Wikidata.getInstance()\n        lod = wd.sparql.queryAsListOfDicts(sparql_query)\n        label = None\n        if len(lod) == 1:\n            label = lod[0][\"itemLabel\"]\n        return label\n\n    def getClassQids(self, qids: list) -&gt; dict:\n        \"\"\"\n        get the Wikidata Q-Identifiers\n        for the given wikidata ids\n\n        Args:\n            qids(list): the list of id\n        \"\"\"\n        sparql_query = f\"\"\"# get the instanceof values for a given entity\nSELECT ?item ?itemLabel ?qid ?class_qid ?class ?classLabel\nWHERE \n{{\n  VALUES ?item {{\n\"\"\"\n        for qid in qids:\n            if not qid.startswith(\"http:\"):\n                wd_url = f\"http://www.wikidata.org/entity/{qid}\"\n            else:\n                wd_url = qid\n            sparql_query += f\"    &lt;{wd_url}&gt;\\n\"\n        sparql_query += f\"\"\"}}\n  ?item wdt:P31/wdt:P279* ?class.\n  ?item rdfs:label ?itemLabel\n  FILTER(LANG(?itemLabel)=\"en\")\n  ?class rdfs:label ?classLabel\n  FILTER(LANG(?classLabel)=\"en\")\n  BIND(REPLACE(STR(?class),\"http://www.wikidata.org/entity/\",\"\") AS ?class_qid)\n  BIND(REPLACE(STR(?item),\"http://www.wikidata.org/entity/\",\"\") AS ?qid)\n}}\"\"\"\n        if self.debug:\n            print(sparql_query)\n        class_rows = self.sparql.queryAsListOfDicts(sparql_query)\n        class_map = LOD.getLookup(class_rows, \"qid\", withDuplicates=True)\n        return class_map\n</code></pre>"},{"location":"#skg.wikidata.Wikidata.__init__","title":"<code>__init__(endpoint='https://query.wikidata.org/sparql', debug=False)</code>","text":"<p>constructor</p> Source code in <code>skg/wikidata.py</code> <pre><code>def __init__(\n    self, endpoint: str = \"https://query.wikidata.org/sparql\", debug: bool = False\n):\n    \"\"\"\n    constructor\n    \"\"\"\n    self.endpoint = endpoint\n    self.sparql = SPARQL(endpoint)\n    self.debug = debug\n    Wikidata.instance = self\n</code></pre>"},{"location":"#skg.wikidata.Wikidata.getClassQids","title":"<code>getClassQids(qids)</code>","text":"<p>get the Wikidata Q-Identifiers for the given wikidata ids</p> <p>Parameters:</p> Name Type Description Default <code>qids(list)</code> <p>the list of id</p> required Source code in <code>skg/wikidata.py</code> <pre><code>    def getClassQids(self, qids: list) -&gt; dict:\n        \"\"\"\n        get the Wikidata Q-Identifiers\n        for the given wikidata ids\n\n        Args:\n            qids(list): the list of id\n        \"\"\"\n        sparql_query = f\"\"\"# get the instanceof values for a given entity\nSELECT ?item ?itemLabel ?qid ?class_qid ?class ?classLabel\nWHERE \n{{\n  VALUES ?item {{\n\"\"\"\n        for qid in qids:\n            if not qid.startswith(\"http:\"):\n                wd_url = f\"http://www.wikidata.org/entity/{qid}\"\n            else:\n                wd_url = qid\n            sparql_query += f\"    &lt;{wd_url}&gt;\\n\"\n        sparql_query += f\"\"\"}}\n  ?item wdt:P31/wdt:P279* ?class.\n  ?item rdfs:label ?itemLabel\n  FILTER(LANG(?itemLabel)=\"en\")\n  ?class rdfs:label ?classLabel\n  FILTER(LANG(?classLabel)=\"en\")\n  BIND(REPLACE(STR(?class),\"http://www.wikidata.org/entity/\",\"\") AS ?class_qid)\n  BIND(REPLACE(STR(?item),\"http://www.wikidata.org/entity/\",\"\") AS ?qid)\n}}\"\"\"\n        if self.debug:\n            print(sparql_query)\n        class_rows = self.sparql.queryAsListOfDicts(sparql_query)\n        class_map = LOD.getLookup(class_rows, \"qid\", withDuplicates=True)\n        return class_map\n</code></pre>"},{"location":"#skg.wikidata.Wikidata.getLabelForQid","title":"<code>getLabelForQid(qid, lang='en')</code>  <code>classmethod</code>","text":"<p>get a label for the given Wikidata QID</p> <p>Parameters:</p> Name Type Description Default <code>qid(str)</code> <p>the Wikidata ID</p> required <code>lang(str)</code> <p>the language</p> required Source code in <code>skg/wikidata.py</code> <pre><code>    @classmethod\n    def getLabelForQid(self, qid: str, lang: str = \"en\") -&gt; str:\n        \"\"\"\n        get a label for the given Wikidata QID\n\n        Args:\n            qid(str): the Wikidata ID\n            lang(str): the language\n        \"\"\"\n        sparql_query = f\"\"\"SELECT ?itemLabel WHERE {{\n  VALUES ?item {{\n    wd:{qid}\n  }}\n  ?item rdfs:label ?itemLabel.\n  FILTER(LANG(?itemLabel)=\"{lang}\").\n}}\"\"\"\n        wd = Wikidata.getInstance()\n        lod = wd.sparql.queryAsListOfDicts(sparql_query)\n        label = None\n        if len(lod) == 1:\n            label = lod[0][\"itemLabel\"]\n        return label\n</code></pre>"}]}